<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Radon API documentation</title>
  <style type="text/css">
  * {font-family:Tahoma; font-size:14pt;}
  pre {margin:.2em 0; border:thin solid silver; padding:.3em .5em;}
  h1 {font-size:180%; }
  h2 {font-size:150%; color:#088; text-shadow:.1em .1em .2em #AAA; border-top:0.5em solid silver;}
  h3 {font-size:125%; color:#088; border-top:0.2em solid #088;}
  h4 {font-size:110%; color:#055; margin:0.8em 0 0.3em 0;}
  h5 {font-size:90%; color:#000; margin:0.4em 0 0 0;}

  /* Для свойств и методов класса ссылка на класс */
  .parent-ref {float:right; margin:0.2em 0 0 1em; font-size:80%; font-weight:200;
    border:thin #055 solid; border-radius:0.2em; padding:0.1em 0.5em; }

  a {text-decoration:none;}
  body { text-align:center;}
  .space {margin:1em;} /* Пространство вокруг элемента */
  #all-text {max-width:50em; text-align:left; display:inline-block;}
  .coderef { font-family:Courier New; } /* ссылка на функцию или свойство */
  .jscript {} /* JavaScript код */
  .signature {font-family:Courier; font-size:90%;} /* Сигнатура метода */
  .demo-err {border-bottom:double .3em red;} /* Демонстрация ошибки в коде */
  .warning { border:thin solid #8DD; border-left-width:1em; margin: .1em 0; padding: 0.3em 1em; } /* Текст, выделяющий важную информацию */
  .warning::before { content: "!"; font-weight: bold; position: absolute; margin-left: -1.4em; font-family:Times; font-size:120%;}
  .examples-ref {padding: 0.3em 2em; color:#005;} /* Блок со ссылкой на Сборник примеров */
  .examples-ref::before { content: "i"; font-weight: bold; position: absolute; margin-left: -1.8em; padding-top:0.1em;
    display:inline-block; width:1.2em; height:1.2em; background-color:#00C; color:#FFF; font-family: Serif; font-size:100%;
    background: linear-gradient(to bottom, #00F, #005);
    text-align:center; border-radius:0.6em; text-shadow:0.05em 0.05em 0.1em #000;}
  
  .rn-ctrl { padding: 0.2em 1em; }
  .color-picker .rn-ctrl { padding:0.1em 0;}
  .rn-ctrl .title { display:inline-block; width:7em; text-align:right; vertical-align:top; margin-right:0.7em; }
  .color-picker .title {width:8em;}
  .color-demo { display: inline-block; vertical-align:top; height:2em; width:8em; border:thin black solid; background-color:#F00;}
  
  /* таблицы ссылок на свойства класса */
  .ref-tbl-hdr {font-weight:bold; font-family:Tahoma; font-size:90%;}
  .ref-tbl { border-collapse:collapse;}
  .ref-tbl td, .ref-tbl th { border: thin solid silver; padding:0.2em 1em; }
  .ref-tbl th { background-color:#DDD; font-size:80%; }
  /* оглавления */
  .ref-list {}
  .ref-list li {line-height:1;}
  /* html colors */
  .hc-root, .hc-root * { font-family:Tahoma; }
  .hc-tagbr {color:#360036;}/* угловые скбки */
  .hc-tag { color:#5f0093; } /* тег */
  .hc-attr { color:#00f;} /* attr name */
  .hc-val { color:#367f5f;} /* attr value */
  .hc-comm {color:silver;}
  .hc-templ {color:magenta;} /* template instruction {{xx}} */
  /* CSS colors */
  .css {}
  .css-class {color: rgb(163,21,21);} /* CSS-class name */
  .css-tag {color: rgb(163,21,21);} /* tag name */
  .css-prop {color: #F00;} /* CSS property name */
  .css-val {color:#00F;} /* CSS property value */
  .css-color {color:#80A;} /* color in css */
  .css-color-square { display:inline-block; width:0.8em; height:0.8em; border:thin solid black; margin:0 0.1em; padding:0 }
  /* JavaScript colors */
  .js-comm {color:Green;}
  .js-str {color:magenta;}
  .js-keyw {color:Blue;}
  .js-regexp {color:#C00;}
  /* SVG */
  .object-box {stroke:#800000; fill:#ffffb9; rx:5px; width:80px; height:18px; } /* рамка для объекта */
  .object-text, .class-text {text-anchor:middle; fill:black; font-family:Tahoma; font-size:14px; font-weight:bold; }
  .ref-text {text-anchor:middle; fill:blue; font-family:Tahoma; font-size:14px; }
  .line { stroke:#800000; stroke-width:1px; fill:none; }
  .class-box {stroke:#800000; fill:#ffffb9; } /* рамка для класса */
  svg a:hover .class-text {fill:#00E;}
  .class-text.selected { font-size:16px; fill:#007; } /* Обычно, класс, обсуждаемый в разделе, на который не делается ссылка */

  .proportion td { vertical-align:middle; text-align:center; padding:0.1em;}
  .proportion .divider { border-top: 0.1em solid black; }
  </style>
    
  <script type="text/javascript">
  // создание элемента, присоединение к владельцу и назначение атрибутов
  function createElem(tag, owner, attrs) {
    var elem = document.createElement(tag);
    if (owner)
      owner.appendChild(elem);
    if (attrs) {
      for (var a in attrs) {
        elem.setAttribute(a, attrs[a]);
      }
    }
    return elem;
  }
  
  var rxDelTags = /<[A-Z\/][-A-Z\s\d\/=\"_]*>/ig;
  function getText(elem) {
    var text = elem.innerHTML;
    text = text.replace(rxDelTags,'');
    return text;
  }
  
  var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
  function trim(text) {
    return text == null ? "" :
      ( text + "" ).replace( rtrim, "" );
  }
  function deleteEmptyLines(text) {
    var i=0, lines = text.split("\n"), j=lines.length-1, dst=[];
    for (i in lines) {
      if (!/^[\s]*$/.test(lines[i])) dst.push(lines[i]);
    }
    return dst.join('\n');
  }
  
  // Генерация основного оглавления
  function genMainReference(level) {
    var prevLevel=level-1, h3Tag='H'+level, h2Tag='H'+prevLevel;
    var i, h3, alist, id, h3list = document.getElementsByTagName(h3Tag);
    for (i=0; i<h3list.length; i++) {
      h3 = h3list[i];
      alist = h3.getElementsByTagName('A');	// ищем ссылку внутри заголовка
      if (alist.length==1) {
        id = alist[0].getAttribute('id');
        if (id) { // Найденный h3 должен быть включен в оглавление
          var h2 = h3;
          while (h2 && h2.tagName!=h2Tag)
            h2 = h2.previousSibling;
          var ul = h2.nextSibling;
          if (ul.tagName!='UL' || ul.className!='ref-list') {
            ul = createElem('UL');
            ul.className='ref-list';
            h2.parentNode.insertBefore(ul, h2.nextSibling);
          }
          var li = createElem('LI', ul);
          var ref = createElem('A',li,{href:'#'+id});
          ref.innerHTML = getText(h3);
        }
      }
    }
  }

  // Генерация таблиц ссылок на свойства класса
  function genRefTables() {
    var elem, tagName, curTable=0, tbody, hdr, pair, refKey, id="ID", tr, td,
            ref, ownerClass;
    for (elem = document.getElementById('RefBegin'); elem; elem=elem.nextSibling) {
      tagName = elem.tagName;
      if (tagName=='H3') {
        curTable = 0;
        pair = getText(elem).split(' - ');
        ownerClass = trim(pair[0]);
      } else if (tagName=='H4') {
        if (!curTable) {
          hdr = createElem('div', 0, {'class': 'ref-tbl-hdr'});
          curTable = createElem('table', 0, {'class':'ref-tbl'});
          tbody = createElem('tbody', curTable);
          hdr.innerHTML = 'Методы и свойства';
          elem.parentNode.insertBefore(hdr, elem);
          elem.parentNode.insertBefore(curTable, elem);
        }
        pair = getText(elem).split(' - ');
        if (pair.length==2) {
          refKey = elem.getElementsByTagName('A')[0].id;
          tr = createElem('tr', tbody);
          td = createElem('td', tr);
          td.innerHTML = '<a href=#'+refKey+' class="coderef">'+pair[0]+'</a>';
          td = createElem('td', tr);
          td.innerHTML = pair[1];
        }
        // Ссылка на класс
        ref = createElem('a',0, {href:'#Ref_'+ownerClass, 'class':'parent-ref'});
        ref.innerHTML = 'класс '+ownerClass;
        elem.insertBefore(ref, elem.firstChild);

      }
    }
  }

  function colorizeHtml(src) {
    var i, j, t, e, c, p, s, k, m, tb = src.split('<');
    function span(cls,val) {
      return '<span class="hc-'+cls+'">'+val+'</span>';
    }
    for (i=1; i<tb.length; i++) {
      p = tb[i].split('>');
      t = p[0]; e = p[1];
      c = t[0];
      if (c=='!') { // comment
        t = span('comm','&lt;'+t+'&gt;');
      } else if (c=='/') { // </tag>
        t = span('tagbr','&lt;/')+span('tag',t.substring(1))+span('tagbr','&gt;');
      } else { // <tag
        c = '&gt;';
        s = t;
        t = span('tagbr','&lt;');
        if (s[s.length-1]=='/') { c = '/'+c; s=s.substring(0,s.length-1); }
        j = s.indexOf(' ');
        if (j<0) t+=span('tag',s);
        else {
          t+=span('tag',s.substring(0,j))+'<span class="hc-attr">';
          p = s.substring(j).split('"');
          for (j=0; j<p.length; j++) {
            t+=(j&1) ? '"'+span('val',p[j])+'"' : p[j];
          }
          t+='</span>';
        }
        t += span('tagbr',c); 
      }
      tb[i] = t+e;
    }
    // теперь шаблонные конструкции...
    tb = tb.join('').split('{{');
    for (i=1; i<tb.length; i++) {
      p = tb[i].split('}}');
      tb[i] = span('templ','{{'+p[0]+'}}')+p[1];
    }
    return deleteEmptyLines(tb.join(''));
  }

  function colorizeCSS(text) {
    var i, j, rule, pieces = text.split('}'),
            pair, right;
    function colorBoxes(str) {
      var i, s, pieces = str.split('#'),
              result = pieces[0];
      function makeColor(len) {
        var col = '#'+s.slice(0, len);
        result += '<span class="css-color">'+ col+
                        '<span class="css-color-square" style="background-color:'+col+'"></span>'+
                '</span>'+ s.slice(len);
      }
      for (i=1; i<pieces.length; i++) {
        s = pieces[i];
        if (/^[0-9A-F]{6}/i.test(s)) {
          makeColor(6);
        } else if (/^[0-9A-F]{3}/i.test(s)) {
          makeColor(3);
        } else {
          result += '#'+s;
        }
      }
      return result;
    }
    for (i=0; i<pieces.length-1; i++) {
      // Пока что внутри правил нет комментов
      rule = pieces[i];
      pair = rule.split('{');
      rule = '<span class="css-class">'+pair[0]+'</span>';
      rule += '{';
      right = pair[1].split(';')
      for (j=0; j<right.length-1; j++) {
        pair = right[j].split(':');
        right[j] = '<span class="css-prop">'+pair[0]+'</span>' + ':' +
          '<span class="css-val">'+colorBoxes(pair[1])+'</span>';
      }
      rule += right.join(';');
      rule += ' }'
      pieces[i] = rule;
    }
    return pieces.join('');
  }
  
  // Раскраска JavaScript-синтаксиса
  var JSKW = /[^A-Za-z\d]var[^A-Za-z\d]|[^A-Za-z\d]function[^A-Za-z\d]|[^A-Za-z\d]return[^A-Za-z\d]|[^A-Za-z\d]this[^A-Za-z\d]|[^A-Za-z\d]if[^A-Za-z\d]|[^A-Za-z\d]else[^A-Za-z\d]|[^A-Za-z\d]for[^A-Za-z\d]|[^A-Za-z\d]do[^A-Za-z\d]|[^A-Za-z\d]while[^A-Za-z\d]|[^A-Za-z\d]delete[^A-Za-z\d]|[^A-Za-z\d]case[^A-Za-z\d]|[^A-Za-z\d]switch[^A-Za-z\d]|[^A-Za-z\d]default[^A-Za-z\d]|[^A-Za-z\d]break[^A-Za-z\d]|[^A-Za-z\d]continue[^A-Za-z\d]/g;
  function colorizeJS(text) {
    function span(cls,val) {
      return '<span class="js-'+cls+'">'+val+'</span>';
    }
    function cvtKeywords(text) {
      return text
         // Выделение регэкспа. Может сглючить, если в строке будет выражение с двумя операциями деления
         // А ещё внутри регэкспа не должно быть слэша
        .replace(/\/[^\/]+\/[gi]*/g, '<span class="js-regexp">$&</span>')
        .replace(JSKW,'<span class="js-keyw">$&</span>');
    }
    function cvtStrings(text) {
      var i, s, pieces = text.split(/([\'\"])/), bCode=1;
      for (i=0; i<pieces.length; i++) {
        switch (i&3) {
        case 0:
          pieces[i] = cvtKeywords(pieces[i]);
          break;
        case 1:
          pieces[i]='<span class="js-str">'+pieces[i];
          break;
        case 3:
          pieces[i]+='</span>';
          break;
        }
      }
      return pieces.join('');
    }
    // в первую очередь, обрабатываем комментарии. Считаем, что в примерах только комменты со слэшами.
    // а также считаем, что двойные слэши не попадаются внутри строк
    var i, pieces = text.split("\n"), pair, txt;
    for (i in pieces) {
      pair = pieces[i].split('//');
      txt = cvtStrings(pair[0]);
      if (pair[1]) txt += span('comm','//'+pair[1]);
      pieces[i]=txt;
    }
    return deleteEmptyLines(pieces.join("\n"));
  }

  function _init() {
    // Раскраска html-кода
    var i, elemX, elemD, parent, xmps = document.getElementsByTagName('xmp');
    for (i=xmps.length-1; i>=0; i--) {
      elemX = xmps[i];
      elemD = document.createElement('pre');
      elemD.setAttribute('class','hc-root');
      elemD.innerHTML = colorizeHtml(elemX.innerHTML);
      parent = elemX.parentNode;
      // вставить вместо elemX
      parent.insertBefore(elemD, elemX);
      parent.removeChild(elemX);
    }
    // Расцветка скриптовых примеров
    var c, pres = document.getElementsByTagName('pre');
    for (i=0; i<pres.length; i++) {
      elemX = pres[i];
      c = elemX.getAttribute('class');
      if (c=='jscript') {
        elemX.innerHTML = colorizeJS(elemX.innerHTML);
      } else if (c=='css') {
        elemX.innerHTML = colorizeCSS(elemX.innerHTML);
      }
    }
    // Создание справочных таблиц
    genRefTables();
    // Создание общего оглавления
    genMainReference(2);
    genMainReference(3);
  }

  </script>
</head>


<body onload="_init()">
<div id="all-text">
  <h1>Браузерная система управления данными Radon</h1>
  Текущая версия системы: 2.0
  <h2><a id="TxIntro"></a>Вступление</h2>
  <p>
    Основное назначение системы Radon - управление вводом данных на html-страницах.
    Зачем для этого нужна специальная система?
    Дело в том, что давно прошли времена, когда было достаточно описать html-форму, отправляющую данные на сервер.
    Сейчас появилась возможность создавать браузерные приложения с богатой функциональностью на основе использования AJAX, HTML5, SVG и т.д.
    Часто бывает необходимо обеспечить ввод данных с последующим использованием их в AJAX-запросах.
    А возможен вариант полноценной обработки данных самим клиентским приложением без отправки их на сервер.
  </p>
  <p>
    Но при вводе данных возникает множество нюансов. Например, вводимые значения нужно проверять на правильность.
    Часто нужно обеспечить сохранность введенных данных при смене страниц или нажатии F5.
    Кроме того, не редкость, когда от значения одних полей зависит наличие или формат данных других полей.
    Эти и другие вопросы эффективно решает система Radon.
  </p>
  <p>
    Конечно, на данный момент уже имеется огромное количество JavaScript-библиотек, автоматизирующих те или иные аспекты разработки WEB-приложений.
    Например, jquery.validate.js позволяет легко организовать проверку правильности данных.
    Но она не поможет в вопросах сохранения данных или взаимодействия элеменов ввода друг с другом.
    Другими словами, автору не известно о существовании систем, которые решали бы проблемы ввода данных не по отдельности, а в комплексе.
  </p>
  <p>
    Концепция системы Radon состоит в организации некоторой модели данных.
    Пользователь должен описать необходимую структуру данных при помощи инструментов, предлагаемых системой Radon.
    Это позволяет сконцентрироваться на сути решаемой задачи и не тратить время на рутинные операции.
    Кроме того, полученная структура в значительной мере удерживает проект от хаоса, часто возникающего в процессе внесения последующих изменений.
  </p>
  <p>
    Система ориентирована на использование профессиональными верстальщиками (вебмастерами).
    Это не значит, что она слишком сложна. Просто обычно необходимость в использовании такой системы появляется в том случае,
    когда разработчик уже неоднократно решал задачи, связанные с вёрсткой сложных форм и решил, что пора найти для этого хороший инструмент.
  </p>
  <p>
    Предполагается, что читатель достаточно хорошо владеет технологиями HTML, CSS, JavaScript. А так же jQuery.
    Потому что в документе имеется множество примеров, но пояснения касаются лишь особенностей функционирования системы Radon.
  </p>

  <h2><a id="TxCommonDescr"></a>Общее описание системы</h2>
  <h3><a id="TxModel"></a>Описание модели данных</h3>
  <p>
  Система Radon предлагает пользователю вполне определённую иерархическую модель описания данных.
  Термин Модель здесь достаточно условный и не соответствует в полной мере тому, который используется в MVC (Model-Controller-View)
  </p>
<svg id="Diag_RadonModel" width="14.5em" height="14.5em" viewBox="0 0 290 290" style="float:right; margin-left:2em;">
  <rect class="class-box" x="105" y="6" width="80" height="22" rx="10" ry="10" />
  <text class="object-text" x="145" y="22">Radon</text>
  <rect class="class-box" x="5" y="70" width="80" height="22" rx="10" ry="10" />
  <text class="object-text" x="45" y="86">page1</text>
  <rect class="class-box" x="105" y="70" width="80" height="22" rx="10" ry="10" />
  <text class="object-text" x="145" y="86">page2</text>
  <rect class="class-box" x="205" y="70" width="80" height="22" rx="10" ry="10" />
  <text class="object-text" x="245" y="86">page3</text>
  <line class="line" x1="65" y1="70" x2="125" y2="28" />
  <line class="line" x1="145" y1="70" x2="145" y2="28" />
  <line class="line" x1="225" y1="70" x2="165" y2="28" />
  <rect class="class-box" x="5" y="134" width="80" height="22" rx="10" ry="10" />
  <text class="object-text" x="45" y="150">form1</text>
  <line class="line" x1="65" y1="134" x2="125" y2="92" />
  <rect class="class-box" x="105" y="134" width="80" height="22" rx="10" ry="10" />
  <text class="object-text" x="145" y="150">form2</text>
  <line class="line" x1="145" y1="134" x2="145" y2="92" />
  <rect class="class-box" x="205" y="134" width="80" height="22" rx="10" ry="10" />
  <text class="object-text" x="245" y="150">form3</text>
  <line class="line" x1="225" y1="134" x2="165" y2="92" />
  <rect class="class-box" x="5" y="198" width="80" height="22" rx="10" ry="10" />
  <text class="object-text" x="45" y="214">ctrl1</text>
  <line class="line" x1="65" y1="198" x2="125" y2="156" />
  <rect class="class-box" x="105" y="198" width="80" height="22" rx="10" ry="10" />
  <text class="object-text" x="145" y="214">ctrl2</text>
  <line class="line" x1="145" y1="198" x2="145" y2="156" />
  <rect class="class-box" x="205" y="198" width="80" height="22" rx="10" ry="10" />
  <text class="object-text" x="245" y="214">ctrl3</text>
  <line class="line" x1="225" y1="198" x2="165" y2="156" />
  <rect class="class-box" x="5" y="262" width="80" height="22" rx="10" ry="10" />
  <text class="object-text" x="45" y="278">ctrl2_1</text>
  <line class="line" x1="65" y1="262" x2="125" y2="220" />
  <rect class="class-box" x="105" y="262" width="80" height="22" rx="10" ry="10" />
  <text class="object-text" x="145" y="278">ctrl2_2</text>
  <line class="line" x1="145" y1="262" x2="145" y2="220" />
  <rect class="class-box" x="205" y="262" width="80" height="22" rx="10" ry="10" />
  <text class="object-text" x="245" y="278">ctrl2_3</text>
  <line class="line" x1="225" y1="262" x2="165" y2="220" />
</svg>
  <p>
  Рисунок справа демонстрирует пример структуры данных.
  На верхней ступени иерархии находится объект <a href="#Ref_Rn">Radon</a> (или сокращённо <b>Rn</b>).
  Ему принадлежат виртуальные страницы. В них могут быть включены <a href="#TxForm">формы</a> ввода данных.
  Формы, в свою очередь, владеют <a href="#TxCtrl">контроллерами</a>.
  Контроллер может служить для ввода одного или нескольких значений. А ещё контроллер может быть владельцем других контроллеров.
  </p>
  <p>
  Следующий листинг демонстрирует, как эта модель может быть описана при помощи Radon.
  </p>
  <div style="clear:both"></div>
  <xmp>
    <div class="rn-page" data-name="page1"></div>
    <div class="rn-page" data-name="page2">
      <form class="rn-form" name="form1"></form>
      <form class="rn-form" name="form2">
        <div class="rn-ctrl" data-name="ctrl1" data-type="String" data-title="Поле №1"></div>
        <div class="rn-ctrl" data-name="ctrl2" data-type="Group">
          <div class="rn-ctrl" data-name="ctrl2_1" data-type="String" data-title="Поле №2.1"></div>
          <div class="rn-ctrl" data-name="ctrl2_2" data-type="String" data-title="Поле №2.2"></div>
          <div class="rn-ctrl" data-name="ctrl2_3" data-type="String" data-title="Поле №2.3"></div>
        </div>
        <div class="rn-ctrl" data-name="ctrl3" data-type="String" data-title="Поле №3"></div>
        <button class="rn-submit">Применить</button>
      </form>
      <form class="rn-form" name="form3"></form>
    </div>
    <div class="rn-page" data-name="page3"></div>
    <!-- Шаблон строкового контроллера -->
    <div id="TmCtrlString" style="display:none">
      <div>
        <span>{{title}}:</span>
        <input type="text" name="{{name}}"/>
      </div>
    </div>
  </xmp>
  <p>
    Конечно, пример не имеет практического смысла и описан весьма схематично, чтобы дополнительные детали не отвлекали от сути.
    Но это действующий код, в котором не хватает только подключения ресурсов и <a href="#TxRn_init">инициализации системы</a>.
    Далее мы рассмотрим более интересные и полезные примеры.
    А здесь следует обратить внимание на следующие концептуальные особенности:
    <ul>
      <li>Описание модели данных осуществляется не в скрипте, а при помощи html.</li>
      <li>Это не только описание данных, но и вёрстка, полностью определяющая внешний вид страницы.</li>
      <li>Элементы, которые контролируются Radon, обозначены классами: rn-page, rn-form, rn-ctrl, rn-submit</li>
      <li>Внутри формы отсутствуют теги input.</li>
      <li>Контроллер сам генерирует собственное содержимое, используя <a href="#TxTempl">шаблон</a>.</li>
    </ul>
  </p>
  <p>
    Вероятно, многим покажется странным и непривычным, что описание данных происходит без участия скрипта.
    С другой стороны, весьма удобно, когда рабочий код сконцентрирован в одном месте.
    Кроме того, вебмастер практически ничем не ограничен при вёрстке.<br />
    Конечно же, данные из описанной модели доступны в скрипте.
    Например, если нужно получить все данные для страницы page2, нужно вызвать:<br />
    <pre class="jscript">
    Rn.getPageEx('page2').save()
    </pre>
    В результате будет получена следующая структура данных:
  </p>
  <pre>
  {
      form1: {},
      form2: {
          ctrl1: "",
          ctrl2: { ctrl2_1:"", ctrl2_2:"", ctrl2_3:"" },
          ctrl3: ""
      },
      form3: {}
  }
  </pre>
  <p>
    Тут подразумевается, что пользователь ещё ничего не ввёл в полях формы. Иначе вместо пустых строк были бы соответствующие значения.<br />
    Ну а если есть <a href="#Ref_PageBase_save">save</a>, значит есть и <a href="#Ref_PageBase_load">load</a>, который принимает такую структуру.
    Естественно, после выполнения load в полях формы появятся новые значения.
  </p>
  <h3><a id="TxRn_init"></a>Инициализация системы</h3>
  <p>
    Система Radon должна быть явно проинициализирована. То есть, без вызова <a href="#Ref_Rn_init">Radon.init()</a> ничего работать не будет.
  </p>

  <h3><a id="TxRnObject"></a>Radon-объект</h3>
  <p>
    Система Radon активно использует наследование классов. Например, CtrlString наследуется от CtrlBase.
    В таких языках как Java или PHP для этого нужно было бы написать такой код:
    <pre>class CtrlString extends CtrlBase {...}</pre>
    Но, к сожалению, в JavaScript такой возможности нет. Поэтому пришлось реализовать собственный механизм.<br/>
    Данный механизм жестко ориентирован на особенности системы Radon и не претендует на универсальность.
  </p>
  <p>
    Radon-объект конструируется из html-тегов, отмеченных классами rn-page, rn-form и rn-ctrl.<br/>
    Имя класса состоит из префикса и краткого имени. Вот три базовых класса:
    <a href="#Ref_PageBase">PageBase</a>, <a href="#Ref_FormBase">FormBase</a>,
    <a href="#Ref_CtrlBase">CtrlBase</a>.<br />
    То есть, для классов страниц используется префикс Page, для страниц - Form, а для контроллеров - Ctrl.
    Краткое имя у всех базовых классов - Base.<br/>
    Наследник всегда имеет такой же префикс, как у родителя. То есть, имена классов всех контроллеров начинаются с Ctrl.
    Поэтому во всех объявлениях используются краткие имена классов, т.к. их префикс и так известен.
  </p>
 Ещё раз посмотрим на объявление контроллера из примера описания модели данных.
  <xmp>
    <div class="rn-ctrl" data-name="ctrl1" data-type="String" data-title="Поле №1"></div>
  </xmp>
  <p>
    Чтобы эта конструкция работала, внутри radon2.js существует следующий код:
    <pre class="jscript">
    // Базовый класс контроллера
    Rn.Ctrl.Base = function() {...}
    // Абстрактный контроллер для ввода простого значения
    Rn.Ctrl.Value  = function() {
      this.superClass = 'Base';
      ...
    }
    // Контроллер ввода строки
    Rn.Ctrl.String = function() {
        this.superClass = 'Value';
        ...
    }
    </pre>
    Именно так определяется наследование Radon-объектов.
    То есть, конструкторы классов регистрируются в соответствующих разделах <a href="#Ref_Rn">главного объекта Radon</a>.
    А родительский класс указывается свойством <a href="#Ref_RadonObject_superClass">superClass</a>.
  </p>
  То же самое можно было бы записать иначе:
  <pre class="jscript">
    // Контроллер ввода строки
    function CtrlString() {
        this.superClass = 'Value';
        ...
    }
  </pre>
  <p>
    Такая запись выглядит несколько проще, но засоряет глобальную область видимости.
  </p>
  <p>
    Теперь рассмотрим основные свойства <a href="#Ref_RadonObject">Radon-объектов</a>.
    Каждый из них обязательно имеет тип и имя.<br/>
  </p>
  <p>
    Тип определяется при помощи атрибута data-type. 
    Причём, указывается краткое имя типа, т.к. префикс косвенным образом определяется из <code>class="rn-ctrl"</code>.
  </p>
  <p>
    Имя объекта определяется атрибутом <code>data-name="name"</code> или <code>name="name"</code>. 
    Оба способа работают одинаково, просто формальные html-валидаторы "разрешают" использование атрибута name для тега form, но не для div или span.
    А если в одном теге определить и name и data-name, то будет использовано значение из data-name
  </p>
  <p>
    Есть ещё одно важное свойство, которое доступно у любого Radon-объекта из скрипта. Называется оно <code>$def</code>.
    Это jQuery-объект, представляющий тот html-элемент, который был использован для описания Radon-объекта.
  </p>

  <!-- --------------------------------------- -->
  <h3><a id="TxPage"></a>Виртуальные страницы</h3>
  <!-- --------------------------------------- -->
  <p>
    Виртуальные страницы нужны для того, чтобы при помощи одного html-документа без перезагрузок имитировать несколько страниц.
    Например, на одной странице вводятся данные, а на другой отображаются результаты их обработки.
    Обычно в каждый момент времени пользователь видит только одну страницу, а остальные скрыты.
  </p>
  <p>
    На самом деле, подобный механизм реализован в большом количестве библиотек. Например, в jQuery Mobile.
    Здесь он реализован для того, чтобы избежать лишних зависимостей. И не является ключевой фичей библиотеки.
    Если разработчик использует для этих целей другую библиотеку и не желает от неё отказываться,
    то механизм переключения страниц Radon нужно <a href="#Ref_Rn_bPageSwitch">отключить</a>.
  </p>
  <p>
    Страница является <a href="#TxRnObject">Radon-объектом</a> и описывается при помощи следующей html-конструкции:
    <xmp>
    <div class="rn-page" data-name="PageName">...</div>
    </xmp>
  </p>
  <p>
    После <a href="#TxRn_init">инициализации</a> системы Radon страницы можно получить методом 
    <a href="#Ref_Rn_getPageEx"><code>Rn.getPageEx('PageName')</code></a>
    или из ассоциативного массива <a href="#Ref_Rn_pages">Rn.pages</a>.<br />
    Текущую активную страницу можно получить методом <a href="#Ref_Rn_curPage"><code>Rn.curPage()</code></a>
  </p>
  <p>
    Свойство <a href="#Ref_RadonObject_Sdef">page.$def</a> возвращает jQuery-объект элемента div, который объявил эту страницу.<br />
    Все атрибуты тега div, объявленные через <code class="hc-attr">data-abcd</code>, становятся полями объекта и доступны через page.abcd.
  </p>
  <p>
    Если не объявлено свойство data-type, то оно автоматически считается равным Base. 
    То есть, будет создана страница класса <a href="#Ref_PageBase">PageBase</a>.
  </p>
  <p>
    Свойство title представляет заголовок зтраницы.
    Если отсутствует атрибут data-title, то заголовок читается из тега H1.
  </p>
  
  <!-- --------------------------------------- -->
  <h3><a id="TxForm"></a>Формы</h3>
  <!-- --------------------------------------- -->
  <p>
    Любая страница может содержать несколько форм. Каждая форма может содержать несколько подчинённых контроллеров.
  </p>
  <p>
    Обычно элементом-описателем формы является тег &lt;form&gt;. Для этого есть множество причин.
    Однако, в для системы Radon не имеет значения тег формы. Важно лишь наличие класса rn-form.
  </p>
  <p>
    Базовый класс формы: <a href="#Ref_FormBase">FormBase</a>.
  </p>

  <!-- --------------------------------------- -->
  <h3><a id="TxCtrl"></a>Контроллеры</h3>
  <!-- --------------------------------------- -->
  <p>
    Контроллеры являются основной фичей системы Radon. Их основное назначение - редактирование данных.<br />
    Можно сказать, что они являются заменой устаревших конструкций типа <code>&lt;input /&gt;</code> и им подобных.
  </p>
  <p>
    Базовым классом контроллера является <a href="#Ref_CtrlBase">CtrlBase</a>.
    Все используемые контроллеры являются экземплярами классов-наследников CtrlBase.
  </p>
  <p>
    Контроллер может содержать одно или несколько значений. Кроме того, существуют контроллеры, которые владеют другими контроллерами.
  </p>
  
  <h4>Описание контроллеров</h4>
  <p>
    Рассмотрим описание контроллеров на примере формы авторизации.
  </p>
  <xmp>
  <form class="rn-form" name="Auth" action="#">
    <span class="rn-ctrl" data-name="login" data-type="String" data-title="Логин"></span>
    <span class="rn-ctrl" data-name="pass" data-type="Password" data-title="Пароль"></span>
    <input type="submit" value="Войти" />
  </form>
  <script id="TmCtrlString" type="text/html">
    <input type="{{input_type}}" data-name="{{name}}" placeholder="{{title}}" size="8" />
  </script>
  </xmp>
  В результате мы увидим такую форму:
  <div class="space">
  <form name="Auth-1" action="#" onsubmit="return false">
    <input type="text" name="login" placeholder="Логин" size="8" />
    <input type="password" name="pass" placeholder="Пароль" size="8" />
    <input type="submit" value="Войти" />
  </form>
  </div>
  А если посмотреть полученную DOM-структуру при помощи инспектора, то увидим следующее:
  <xmp>
  <form class="rn-form" name="Auth" action="#">
    <span class="rn-ctrl" data-name="login" data-type="String">
      <input type="text" name="login" placeholder="Логин" size="8" />
    </span>
    <span class="rn-ctrl" data-name="pass" data-type="Password">
      <input type="password" name="pass" placeholder="Пароль" size="8" />
    </span>
    <input type="submit" value="Войти" />
  </form>
  </xmp>
  <h4><a id="TxCtrlDefRules"></a>Правила описания контроллеров</h4>
  <ul>
    <li>Описание контроллера расположено внутри формы.</li>
    <li>Описание имеет следующий вид <code>&lt;tag class="rn-ctrl" data-name="..." data-type="..." ...&gt;&lt;/tag&gt;</code></li>
    <li>В примере выше использовался тег span, чтобы форма имела горизонтальное расположение. Но вообще, тег не имеет значения.
      Самое главное - наличие класса <b>rn-ctrl</b>. Именно он является признаком того, что из этого описания нужно сконструировать контроллер.
    </li>
    <li>
      Для большинства контроллеров важно наличие имени, которое задано через атрибут data-name.
    </li>
    <li>
      Тип контроллера задан атрибутом data-type. В нашем примере это <a href="#Ref_CtrlString">String</a> и
      <a href="#Ref_CtrlPassword">Password</a>.
    </li>
    <li>Описание контроллера может содержать различное количество других атрибутов data-some_attr="some value".
      Все они появятся в сгенерированном контроллере в виде свойств some_attr="some value".<br />
      Имена свойств не могут содержать больших букв (ограничение jQuery).
      Имена свойств должны начинаться с латинской буквы и состоять из латинских букв, цифр или знака подчёркивания.
      Правильно: some_attr, неправильно: some-attr, someAttr.
    </li>
    <li>
      Содержимое тега-описателя для большинства контроллеров полностью формируется шаблоном. Старое содержимое уничтожается.<br />
      Правила поиска шаблона для контроллера описаны <a href="#TxCtrlTemplRules">ниже</a>.
      Параметрами шаблона являются все свойства контроллера: и те, которые описаны в конструкторе класса контроллера,
      и те, которые описаны в конструкторах классов-предков, и те, которые заданы в описании при помощи data-xxx.
    </li>
  </ul>
  
  <h4><a id="TxCtrlTemplRules"></a>Правила поиска шаблона для контроллера</h4>
  <ul>
    <li>Если в описании контроллера присутствует атрибут data-tm, то в нём явным образом указано имя шаблона.</li>
    <li>
      Иначе происходит поиск шаблона с именем <code>"TmCtrl"+type</code>.
      Например, для контроллера, в котором задан атрибут data-type="String" может быть найден шаблон TmCtrlString.
    </li>
    <li>Если для данного типа контроллера шаблона нет, то происходит поиск по той же схеме для всех классов-предков.
      Например, для класса <a href="#Ref_CtrlPassword">Password</a> может быть найден шаблон TmCtrlString,
      т.к. <a href="#Ref_CtrlString">String</a> является родителем класса Password.
    </li>
    <li>
      Если никакого шаблона не найдено, генерируется исключение: <a href="#Err_TemplateNotFound">Template not found for type: <em>имя-класса</em></a>
    </li>
  </ul>
  <p>
    Весь описанный процесс поиска выполняется функцией <a href="#Ref_Rn_findTm">Rn.findTm()</a>.
  </p>
  
  <!-- --------------------------------------- -->
  <h3><a id="TxValidator"></a>Валидаторы</h3>
  <!-- --------------------------------------- -->
  <p>
    Валидаторы являются вспомогательными объектами.
    Они могут подключаться к контроллеру, чтобы выполнять проверку правильности ввода данных.
  </p>
  <p>
    Базовым классом для всех валидаторов является <a href="#Ref_ValidatorBase">ValidatorBase</a>
  </p>
  <h5>Список валидаторов, входящих в ядро системы Radon</h5>
  <table class="ref-tbl">
  <tr>
    <th>Класс</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td><a href="#Ref_ValidatorNonEmpty">NonEmpty</a></td>
    <td>Значение не должно быть пустым.</td>
  </tr>
  <tr>
    <td><a href="#Ref_ValidatorRegexp">Regexp</a></td>
    <td>Значение проверяется при помощи регулярного выражения.</td>
  </tr>
  <tr>
    <td><a href="#Ref_ValidatorRange">Range</a></td>
    <td>Значение должно быть числом. Кроме того, могут быть указаны минимальное и максимальное значение</td>
  </tr>
  <tr>
    <td><a href="#Ref_ValidatorInteger">Integer</a></td>
    <td>Значение должно быть целым числом.</td>
  </tr>
  <tr>
    <td><a href="#Ref_ValidatorMinLength">MinLength</a></td>
    <td>Проверка минимальной длины строки.</td>
  </tr>
  <tr>
    <td><a href="#Ref_ValidatorMaxLength">MaxLength</a></td>
    <td>Проверка максимальной длины строки.</td>
  </tr>
  </table>
  
  <p>
    Конечно, могут возникнуть ситуации, когда потребуется валидатор со специфичным поведением.
    В этом случае его несложно сделать самостоятельно.
  </p>
  <p>
    Рассмотрим пример, где в форме есть два поля: тариф и страховая компания.
    Оба представлены контроллером <a href="#Ref_CtrlDroplist">Droplist</a>.
    Тариф может быть полным или детским. А в списке страховых компаний есть вариант "НЕ ВЫБРАНА".
    Для полного тарифа страховая компания не обязательна, а для детского - обязательна.
  </p>
  <h5>HTML</h5>
  <xmp>
  <form class="rn-form" name="vdemo" action="#">
    <div class="rn-ctrl" data-name="tariff" data-type="Droplist" value0="1"
      data-title="Тариф" data-options="TmTariffs"></div>
    <div class="rn-ctrl" data-name="insurance" data-type="Droplist"
      data-title="Страховая компания" data-options="TmInsComp" >
      <!-- Специальный валидатор, описанный ниже функцией ValidatorInsComp -->
      <div class="rn-validator" data-type="InsComp"
        data-msg="Для детского тарифа необходимо выбрать страховую компанию"></div>
    </div>
  </form>
  <!-- Список тарифов -->
  <select style="display:none" id="TmTariffs">
    <option value="1">Полный</option>
    <option value="2">Детский</option>
  </select>
  <!-- Список страховых компаний -->
  <select style="display:none" id="TmInsComp">
    <option value="">НЕ ВЫБРАНА</option>
    <option value="1">Компания № 1</option>
    <option value="2">Компания № 2</option>
  </select>
  <!-- Шаблон для контроллера Droplist -->
  <script id="TmCtrlDroplist" type="text/html">
    <div>
      <span class="title">{{title}}</span>
      <select name="{{name}}"></select>
    </div>
  </script>
  </xmp>
  <h5>JavaScript</h5>
  <pre class="jscript">
function ValidatorInsComp() {
	this.superClass = "Base";
	this.check = function(value) {
		// Получить значение поля Тариф
		var tariff = this.ctrl.owner.ctrls.tariff.val();
		// Если выбран детский тариф (2), то страховая компания не может быть пуста
		if (tariff==2 && !value)
			return this.msg;
	}
}
  </pre>

  <!-- --------------------------------------- -->
  <h3><a id="TxFilters"></a>Фильтры</h3>
  <!-- --------------------------------------- -->
  <p>
    Фильтры являются вспомогательными объектами.
    Они могут подключаться к контроллеру, чтобы выполнять пост-обработку данных.
  </p>


  <!-- #################################### -->
  <h2><a id="TxTempl"></a>Шаблонизация</h2>
  <!-- #################################### -->
  <p>
    В первую очередь, шаблоны используются для генерации содержимого <a href="#TxCtrl">контроллеров</a>.
  </p>
  <p>
    Существует большое количество JavaScript-шаблонизаторов. Наиболее известный - mustache.js.
    Но при разработке Radon было принято решение не привязываться к какой-то конкретной библиотеке.
    Разработчик может настроить Radon на использование своего любимого инструментария.
    А по-умолчанию используется внутренний шаблонизатор, по формату очень похожий на Mustache.
  </p>
  
  <h3><a id="Tx_InternalTempl"></a>Описание встроенного Radon-шаблонизатора</h3>
  <p>
    Этот шаблонизатор крайне примитивен, но решает те задачи, которые необходимы для работы системы.<br />
    Все используемые имена являются простыми названиями полей. Без точек или иных операций.
    Поддерживаются 4 конструкции:
  </p>
  <ul>
    <li>
      Вывод экранированного значения параметра. Например, <code>{{name}}</code>.
    </li>
    <li>
      Вывод неэкранированного значения параметра. Например, <code>{{{name}}}</code>.
    </li>
    <li>
      Условная секция, которая включается если значение параметра соответствует логическому true.
      Например, <code>{{#name}}...{{/name}}</code><br />
      Равносилен JavaScript-конструкции <code>if (params.name) {...}</code>.
    </li>
    <li>
      Условная секция, которая включается если значение параметра соответствует логическому false.
      Например, <code>{{^name}}...{{/name}}</code><br />
      Равносилен JavaScript-конструкции <code>if (!params.name) {...}</code>.
      Значения, при которых сработает условие: false, 0, null, undefined, "", NaN.
    </li>
  </ul>
  <p>
    На программном уровне шаблонизатор реализован функциями <a href="#Ref_Rn_templTextImpl" class="coderef">Rn.templTextImpl()</a>
    и <a href="#Ref_Rn_templIdImpl" class="coderef">Rn.templIdImpl()</a>. 
    Но прямого обращения к ним нигде нет.
  </p>
  
  <h3>Как подключить внешний шаблонизатор</h3>
  <p>
    Подключение внешнего шаблонизатора выполняется путём переопределения свойств глобального объекта Rn.
    Это нужно сделать до его <a href="#TxRn_init">инициализации</a>.
  </p>
  <p>
    Если Ваш шаблонизатор выполняет только подстановку параметров в текст, то достаточно переопределить
    <a href="#Ref_Rn_templText" class="coderef">Rn.templText</a>. Например:
  </p>
  <pre class="jscript">
  Rn.templText = function(text, params) {
    Mustache.render(text, params);
  }
  </pre>
  PS. В данном случае, можно короче: <code>Rn.templText = Mustache.render;</code>
  <p>
    Если Вы заинтересованы в повышении быстродействия, то наверняка захотите использовать прекомпилируемые шаблоны.
    В этом случае следует переопределить свойство <a href="#Ref_Rn_templId" class="coderef">Rn.templId</a>.
    Например, вот как можно подключить шаблонизатор Handlebars:
  </p>
  <pre class="jscript">
  var cache = {};
  Rn.templId = function(tmId, params) {
    var template = cache[tmId];
    if (!template) {
      template = cache[tmId] = Handlebars.compile($('#'+tmId).html());
    }
    return template(params);
  }
  </pre>
  
  <h3><a id="TxTemplCircuit"></a>Цепочка вызовов функций шаблонизации</h3>
  <svg width="7.2em" height="10.8em" viewBox="0 0 120 180" style="float:left; margin:0 2em;">
    <rect x="1" y="1" width="118" height="18" class="line" />
    <a xlink:href="#Ref_Rn_tm">
      <text x="60" y="15" class="ref-text">tm()</text>
    </a>
    <path class="line" d="M60 20 V 40 m-6 -8 l6 8 l6 -8" />
    <rect x="1" y="41" width="118" height="18" class="line" />
    <a xlink:href="#Ref_Rn_templId">
      <text x="60" y="55" class="ref-text">templId</text>
    </a>
    <path class="line" d="M62 60 V 77 M58 60 V 77 m-4 -6 l6 8 l6 -8" />
    <rect x="1" y="81" width="118" height="18" class="line" />
    <a xlink:href="#Ref_Rn_templIdImpl">
      <text x="60" y="95" class="ref-text">templIdImpl()</text>
    </a>
    <path class="line" d="M60 100 V 120 m-6 -8 l6 8 l6 -8" />
    <rect x="1" y="121" width="118" height="18" class="line" />
    <a xlink:href="#Ref_Rn_templText">
      <text x="60" y="135" class="ref-text">templText</text>
    </a>
    <path class="line" d="M62 140 V 157 M58 140 v 17 m-4 -6 l6 8 l6 -8" />
    <rect x="1" y="161" width="118" height="18" class="line" />
    <a xlink:href="#Ref_Rn_templTextImpl">
      <text x="60" y="175" class="ref-text">templTextImpl()</text>
    </a>
  </svg>
  <p>
    Здесь представлена последовательность вызова функций шаблонизации, используемая по-умолчанию.<br />
    Обычная стрелка соответствует вызову функции, а двойная означает ссылку.
  </p>
  <div style="clear:both"></div>
  
  <h3><a id="TxTemplates"></a>Правила описания шаблонов</h3>
  <p>
    В первую очередь, эти правила относятся к встроенному шаблонизатору.
    Для Mustache они также полностью подходят.
  </p>
  <p>
    Для объявления шаблона рекомендуется использовать конструкцию:
    <xmp>
    <script id="TmName" type="text/html">
      ...
    </script>
    </xmp>
    В принципе, можно использовать любой тег, но нужно учитывать ряд особенностей:
    <ul>
      <li>
        Тег должен быть невидим. То есть, необходимо использовать <code>style="display:none"</code>.
        Либо, нужно организовать общий невидимый контейнер для шаблонов.
      </li>
      <li>
        Необходимо помнить, ряд тегов можно применять только при определённом сочетании.
        Например, тег TD нельзя вставить в DIV, а только в TR.
      </li>
      <li>
        Условные конструкции внутри тега можно применять только внутри шаблона, объявленного через &lt;script&gt;
        <xmp>
          <input type="text" {{#placeholder}}placeholder={{placeholder}}{{/placeholder}} />
        </xmp>
        Иначе слэш в {{/placeholder}} воспринимается как конец тега.
      </li>
      <li>
        Если использовать такую конструкцию:
        <xmp>
        <div id="TmDemo" style="display:none">
          <img src="/images/{{name}}.jpg" />
        </div>
        </xmp>
        то браузер будет пытаться загрузить этот файл, хотя тег невидимый.
        В результате в консоли будет ошибка о том, что не удалось загрузить {{name}}.jpg.
      </li>
    </ul>
    При использовании тега script таких проблем не возникает.
    Правда, некоторые IDE не понимают, что указан тип text/html и пытаются воспринимать его как JavaScript.
    В результате появляются ложные сообщения о ошибках.
  </p>

  <!-- #################################### -->
  <h2><a id="TxRuntimeErrors"></a>Ошибки, возникающие при выполнении</h2>
  <!-- #################################### -->
  <p>
    Если система не работает, то сначала нужно убедиться, что вызывается <a href="#TxRn_init"><code>Radon.init</code></a>.
    Далее жмём F12 и смотрим ошибки в консоли.
  </p>
  <h3><a id="Err_PageNotFound"></a>Отсутствие страницы</h3>
  Сообщение: Page not found: <em>имя-страницы</em><br />
  Возможные причины:
  <ul>
    <li>
      Не объявлена нужная страница с указанным именем при помощи конструкции <code>&lt;div class="rn-page"...</code>.
    </li>
    <li>
      В функцию <a href="#Ref_Rn_getPageEx"><code>Rn.getPageEx</code></a> передано ошибочное имя страницы.
    </li>
  </ul>
  
  <h3><a id="Err_ClassNotFound"></a>Не найден конструктор класса</h3>
  Сообщение: Class not found: <em>имя-класса</em><br/>
  Причины:
  <ul>
    <li>Опечатка в атрибуте data-type. Например, <code>&lt;div class="rn-ctrl" data-type="<span class="demo-err">Stringg</span>" ...</code></li>
    <li>Опечатка в имени функции-конструктора. Например, 
      <xmp><div class="rn-page" data-type="MyTest" data-name="xyz"></div></xmp>
      <pre>function <span class="demo-err">PageMyTestt</span>() {...}</pre>
    </li>
    <li>
      Бывает, что разработчик просто забывает написать функцию-конструктор или подключить нужный js-файл
    </li>
    <li>
      Функция-конструктор должна быть описана в глобальном пространстве. То есть, так писать нельзя:
      <pre class="jscript">
      function SomeSpace() {
        function PageMyTest() {...}
      }
      </pre>
    </li>
  </ul>
  
  <h3><a id="Err_TemplateNotFound"></a>Не найден шаблон для типа</h3>
  Сообщение: Template not found for type: <em>имя-класса</em><br />
  Возможные причины:
  <ul>
    <li>Для указанного типа не сделан шаблон.
       Допустим, использован следующий html-код:
       <xmp><div class="rn-ctrl" data-name="test" data-type="String"></div> </xmp>
       Если в документе не окажется шаблона с именем TmCtrlString, то при инициализации системы будет сгенерировано такое исключение.
    </li>
    <li>Ошибка в имени шаблона.<br />
      Например, если вместо TmCtrlString случайно написать <span class="demo-err">TmCtrlStringg</span> или <span class="demo-err">TmCtrlstring</span>.
    </li>
  </ul>
  Генерируется функцией <a href="#Ref_Rn_findTm">Rn.findTm()</a>.<br />
  Также см. <a href="#TxCtrlTemplRules">Правила поиска шаблона для контроллера</a>.

  <!-- ######################################## -->
  <h2 id="RefBegin"><a id="TxProgReference"></a>Справочник программного API</h2>
  <!-- ######################################## -->

  <!-- ------------------------- -->
  <h3><a id="Ref_Rn"></a>Radon - Ядро системы</h3>
  <!-- ------------------------- -->
  <p>
    Глобальный объект Radon содержит базовые функции и настройки системы.
  </p>

  <!-- ========================== -->
  <h4><a id="Ref_Rn_init"></a>init() - Инициализация системы Radon</h4>
  <pre class="signature">void Rn.init(string startPageName="start", jQuery $scope=undefined)</pre>
  <p>
    Общая инициализация системы. Эту функцию необходимо вызвать после загрузки документа.
  </p>
  <ul>
    <li>startPageName - Имя стартовой страницы. В случае отсутствия предполагается имя "start".</li>
    <li>$scope - Элемент, внутри которого будет происходить поиск элементов .rn-page. Если не указан, то поиск пройдёт по всему документу.</li>
  </ul>
    Пример правильного вызова:
  <pre class="jscript">
  $(function(){
    Radon.init();
  });
  </pre>

  <!-- ========================== -->
  <h4><a id="Ref_Rn_getPageEx"></a>getPageEx() - Получение страницы по названию</h4>
  <pre class="signature">PageBase Rn.getPageEx(string pageName)</pre>
  <p>
    Возвращает страницу по имени. Если указанная страница отсутствует, будет сгенерировано <a href="#Err_PageNotFound">исключение</a> с сообщением:
    'Page not found: '+pageName.
  </p>

  <!-- ========================== -->
  <h4><a id="Ref_Rn_curPage"></a>curPage() - Получить текущую страницу</h4>
  <pre class="signature">PageBase Rn.curPage()</pre>
  <p>
    Получить объект текущей страницы.
  </p>

  <!-- ========================== -->
  <h4><a id="Ref_Rn_activate"></a>activate() - Назначить текущую страницу</h4>
  <pre class="signature">void Rn.activate(string pageName)</pre>
  <p>
    Используется для назначения текущей страницы.<br />
    При этом вызовется событие <a href="#Ref_PageBase_onClose" class="coderef">onClose</a> для старой страницы 
    и <a href="#Ref_PageBase_onOpen" class="coderef">onOpen</a> для указанной страницы.
  </p>

  <!-- ========================== -->
  <h4><a id="Ref_Rn_update"></a>update() - Обновить состояние системы</h4>
  <pre class="signature">void Rn.update()</pre>
  <p>
  Оповещение о любых изменениях.<br />
  Вызывает событие <a href="#Ref_RadonObject_onUpdate">onUpdate</a> у всех Radon-объектов текущей страницы.
  Оптимизировано для большого количества вызовов.
  Например, при загрузке данных каждый контроллер может вызвать update, но onUpdate стаботает только один раз, когда всё загрузится.
  </p>
  <p>
    Обновлять состояние системы необходимо после любых вносимых изменений. 
    Например, после вызова <a href="#Ref_RadonObject_load">load()</a>.
  </p>
  
  <!-- ========================== -->
  <h4><a id="Ref_Rn_load"></a>load() - Загрузка данных в объект</h4>
  <pre class="signature">void Rn.load(RadonObject target, Object srcObj)</pre>
  <p>
    Загружает данные из srcObj в target и обновляет состояние системы.<br />
    В качестве target может выступать любой <a href="#Ref_RadonObject">Radon-объект</a>.<br />
    Рекомендуется использовать вместо прямого обращения к <a href="#Ref_RadonObject_load">target.load(srcObj)</a>, 
    так как после загрузки вызывается <a href="#Ref_Rn_update">Rn.update()</a>.
  </p>
  
  <h4><a id="Ref_Rn_initPages"></a>initPages() - Инициализация страниц</h4>
  <pre class="signature">void initPages(jQuery $scope=undefined)</pre>
  <p>
  Вызывается из <a href="#Ref_Rn_init">Rn.init()</a>.
  Специально вызывать эту функцию может потребоваться только в случае динамической подгрузки контента, в котором содержатся объявления страниц.<br />
  Может сгенерировать <a href="#Err_ClassNotFound">исключение</a>, если для какой-либо страницы не получится найти функцию-конструктор.
  </p>

  <!-- ========================== -->
  <h4><a id="Ref_Rn_reset"></a>reset() - Сброс объекта</h4>
  <pre class="signature">void Rn.reset(RadonObject object)</pre>
  <p>
    Выполняет сброс указанного <a href="#Ref_RadonObject">Radon-объекта</a>.
    Иерархически производит вызов метода <a href="#Ref_RadonObject_onReset">onReset</a> для 
    указанного объекта и всех его подчинённых. Конечно, для тех, у кого этот метод есть, т.к. он необязательный.
  </p>
  <p>
    Для удобства все Radon-объекты имеют метод <a href="#Ref_RadonObject_reset">reset()</a>, который и вызывает <code>Rn.reset()</code>.
  </p>
  
  <!-- ========================== -->
  <h4><a id="Ref_Rn_isDisabled"></a>isDisabled(target) - Запрещен ли указанный элемент</h4>
  <pre class="signature">boolean Rn.isDisabled(string|jQuery|DOMElement target)</pre>
  <p>
    Возвращает true, если для указанный элемент был запрещён функцией Rn.enable(target, false)
  </p>
  
  <!-- ========================== -->
  <h4><a id="Ref_Rn_enable"></a>enable() - Резрешить или запретить элемент</h4>
  <pre class="signature">void Rn.enable(string|jQuery|DOMElement target, bool bEnable=true)</pre>
  <p>
    Запрещённый элемент приобретает класс <code class="css-class">disabled</code>
    (можно изменить в Rn.p.clsDisabled) и атрибут <code class="hc-attr">disabled</code>
    (регулируется признаком Rn.p.bUseDisabledAttr).<br />
    Применяется в элементам сабмита формы.
  </p>

  <!-- ========================== -->
  <h4><a id="Ref_Rn_setTextHandler"></a>setTextHandler - Обработчик событий для текстовых элементов</h4>
  <pre class="signature">void Rn.setTextHandler(jQuery $item, function handler)</pre>
  <p>
    Этот метод предназначен для элементов, редактирующих текст.
    К ним относятся &lt;input type="text" /&gt; и &lt;textarea/&gt;.
    Метод цепляет обработчик сразу на несколько событий: change, keyup и input.
  </p>
  <p>
    Следует учесть, что при нажатии клавиши сработают события keyup и input. Поэтому обработчик будет вызван дважды.
    Например, функция <a href="#Ref_CtrlValue_fromDOM">CtrlValue.fromDOM</a> сравнивает значение, полученное из элемента
    и старое значение контроллера. Если они совпадают, то update не вызывается.
    Таким способом предотвращаются бесполезные действия и повышается эффективность.
  </p>
  <p>Рассмотрим пример, в котором возле строки ввода отображается количество символов в тексте.</p>
  <xmp>
  <div id="TextDemo">
    <input type="text" /> <span>0</span>
  </div>
  </xmp>
  <pre class="jscript">
$(function(){
	var length=0, $td = $('#TextDemo'),
		$input=$('input', $td), $span=$('span',$td);
	Rn.setTextHandler($input, function(ev){
		var value = $input.val();
		if (value.length != length) {
			$span.text(length = value.length);
		}
	});
});
  </pre>
  
  <!-- ========================== -->
  <h4><a id="Ref_Rn_findTm"></a>findTm() - Поиск шаблона для указанного объекта</h4>
  <pre class="signature">string Rn.findTm(RadonObject object, String prefix)</pre>
  <p>Возвращает имя шаблона для указанного объекта.<br />
    Если у объекта есть свойство tm, то имя шаблона берётся из него.
    Иначе происходит поиск по имени типа Tm+prefix+type. Перебираются все родители.
    Например, для объекта типа <a href="#Ref_CtrlPassword">CtrlPassword</a> сначала проверяется наличие шаблона TmCtrlPassword.
    Если не найдено, то происходит поиск TmCtrlString.<br />
    Если никакого шаблона не найдено, генерируется <a href="#Err_TemplateNotFound">исключение</a>.
  </p>
  <p>
    Эта функция обычно используется при рендере объектов. Вот реализация функции CtrlBase.render():
  </p>
  <pre class="jscript">
    var tmId = Rn.findTm(this, 'Ctrl');
    Rn.tm(tmId, this, this.$def, 1);
  </pre>
  
  <!-- ========================== -->
  <h4><a id="Ref_Rn_hasTm"></a>hasTm(tmId) - Проверка существования шаблона</h4>
  <pre class="signature">boolean Rn.hasTm(string tmId)</pre>
  <p>
    Возвращает true, если шаблон с указанным ID существует.
  </p>
  
  <!-- ========================== -->
  <h4><a id="Ref_Rn_tm"></a>tm() - Использовать шаблон</h4>
  <pre class="signature">jQuery Rn.tm(string tmId, Object params=undefined,
    jQuery $owner=undefined, int mode=undefined)</pre>
  <p>
    Это основная функция шаблонизации, которая используется системой Radon.
    Она находит шаблон по идентификатору и подставляет параметры.
    Из полученного текста конструируется DOM-элемент, который может быть сразу зарегистрирован в указанном владельце.
    Результатом является jQuery-объект для полученного элемента.
  </p>
  <p>
    Эта функция вызывает <a href="#Ref_Rn_templId">Rn.templId</a>.
  </p>
  <p>
    Если по какой-то причине указанный шаблон окажется не найден, то никаких исключений не генерируется.
    Просто ничего не выполняется.
    Наличие шаблона можно предварительно проверить с помощью функции <a href="#Ref_Rn_hasTm">Rn.hasTm()</a>.
  </p>
  Пример:
  <xmp>
  <div id="demo-view">
  </div>
  <script id="TmDemo" type="text/html">
    <div>
      Улица: {{street}}, дом: {{house}}{{#flat}}, квартира: {{flat}}{{/flat}}.
    </div>
  </script>
  </xmp>
  <pre class="jscript">
  var $owner = $('#demo-view');
  Rn.tm('TmDemo', {street:'Абрикосовая', house:18, flat:3}, $owner);
  Rn.tm('TmDemo', {street:'Виноградная', house:146}, $owner);
  </pre>
  Результат:
  <div>Улица: Абрикосовая, дом: 18, квартира: 3.</div>
  <div>Улица: Виноградная, дом: 146.</div>

  <!-- ========================== -->
  <h4><a id="Ref_Rn_templTextImpl"></a>templTextImpl() - Подстановка параметров в текстовый шаблон встроенным шаблонизатором.</h4>
  <pre class="signature">string Rn.templTextImpl(string text, Object params)</pre>
  <p>
    <a href="#Tx_InternalTempl">Описание формата</a> приводится в разделе описания шаблонизации.
    Пример:
  </p>
  <pre class="jscript">
  var result = Rn.templTextImpl("Длина реки {{name}} составляет {{length}} км.", {
    name: 'Волга', length: 3530
  });
  </pre>
  Результат: Длина реки Волга составляет 3530 км.
  <p>
    Эта функция никогда не вызывается напрямую, а только через <a href="#Ref_Rn_templText">Rn.templText</a>.
    Потому что по-умолчанию Rn.templText = Rn.templTextImpl;
  </p>
  
  <!-- ========================== -->
  <h4><a id="Ref_Rn_templText"></a>templText - Подстановка параметров в текстовый шаблон текущим шаблонизатором.</h4>
  <pre class="signature">string Rn.templText(string text, Object params)</pre>
  <p>
    Это настраиваемое свойство, которое изначально указывает на <a href="#Ref_Rn_templTextImpl">Rn.templTextImpl</a>.
  </p>
  <p>
    Если вместо встроенного шаблонизатора Вы хотите использовать Mustache,
    то для этого перед <a href="#Ref_Rn_init">инициализацией</a> нужно добавить код:
  </p>
  <pre class="jscript">Rn.templText = Mustache.render;</pre>
  <p>
    В большинстве случаев данная функция вызывается из <a href="#Ref_Rn_templIdImpl">Rn.templIdImpl()</a>.
    Прямые обращения из системы Radon к <code>Rn.templText</code> тоже возможны.
    Например, для формирования сообщения некоторых <a href="#TxValidator">валидаторов</a>.
  </p>

  <!-- ========================== -->
  <h4><a id="Ref_Rn_templIdImpl"></a>templIdImpl() - Встроенная функция подстановки параметров в шаблон, указанный через ID</h4>
  <pre class="signature">string Rn.templIdImpl(string tmId, Object params)</pre>
  <p>
    Система Radon предполагает, что шаблоны описываются не в скрипте, а в html.
    Например, вот типичный шаблон для строкового контроллера:
  </p>
  <xmp>
  <script id="TmString" type="text/html">
    <div>
      {{title}}: <input type="text" name="{{name}}" />
    </div>
  </script>
  </xmp>
  <pre class="jscript">var html = Rn.templIdImpl('TmString', {title:'Фамилия', name:'lastName'});</pre>
  В результате переменная html будет иметь такое содержимое:
  <xmp>
    <div>
      Фамилия: <input type="text" name="lastName" />
    </div>
  </xmp>
  <p>
    Функция <code>Rn.templIdImpl</code> не вызывается напрямую.
    Вместо неё используется переопределяемое свойство <a href="#Ref_Rn_templId" class="coderef">Rn.templId</a>.
  </p>
  
  <h4><a id="Ref_Rn_templId"></a>templId - Подстановка параметров в шаблон, указанный через ID</h4>
  <pre class="signature">string Rn.templId(string tmId, Object params)</pre>
  <p>
    Это свойство по-умолчанию указывает на <a href="#Ref_Rn_templIdImpl">Rn.templIdImpl</a>.
    Но его можно переопределить, чтобы подключить внешний шаблонизатор. Причём, это нужно сделать до 
    <a href="#Ref_Rn_Init">инициализации</a>.
  </p>
  <p>
    Параметр tmId соответствует атрибуту id того элемента, который содержит шаблон.
    <a href="#TxTemplates">Правила описания шаблонов</a> перечислены отдельно.
  </p>
  <p>
    Данная функция не вызывается напрямую, а используется высокоуровневой шаблонной конструкцией <a href="#Ref_Rn_tm">Rn.tm()</a>.
  </p>

  <h4><a id="Ref_Rn_buildList"></a>buildList() - Стандартный алгоритм формирования списка вариантов</h4>
  <pre class="signature">void Rn.buildList(Object ctrl, function callbk(mixed value, string label, mixed itemDef))</pre>
  <p>
    В качестве параметра <b>ctrl</b> обычно передаётся контроллер, но технически это объект, который имеет ряд полей:
    <ul>
      <li>options - Обязательное поле. Содержит имя объекта, из которого формируется список.
        Подробнее см. <a href="#Ref_CtrlDroplist_options">CtrlDroplist.options</a>.
      </li>
      <li>option_value - Необязательное поле. Используется только в случае, когда options указывает на скриптовую переменную.
        По-умолчанию равно "value". Подробнее см. <a href="#Ref_CtrlDroplist_option_value">CtrlDroplist.option_value</a>.
      </li>
      <li>option_label - Необязательное поле. Используется только в случае, когда options указывает на скриптовую переменную.
        По-умолчанию равно "label". Подробнее см. <a href="#Ref_CtrlDroplist_option_label">CtrlDroplist.option_label</a>.
      </li>
    </ul>
  </p>
  <p>
    Параметр <b>callbk</b> должен быть функцией со следующей сигнатурой:
    <pre class="signature">void callbk(mixed value, string label, mixed itemDef)</pre>
    Через вызов этой функции происходит наполнение списка в контроллере.
  </p>
  <p>
    Параметр itemDef содержит запись исходной структуры, из которой генерируется список.
    Он может потребоваться только в том случае, если рисуется какой-то расширенный элемент списка,
    для которого недостаточно value и label. Например, для запрещения элементов.
  </p>
  <div>В качестве примера - реализация функции, заполняющей элемент &lt;select&gt; :</div>
  <pre class="jscript">
	var ctrl = this, sel = ctrl.$def.find('select');
	Rn.buildList(ctrl, function(value, label){
		$('&lt;option&gt;').val(value).text(label).appendTo(sel);
	});
	ctrl.val2dom();
  </pre>
  
  <!-- ========================== -->
  <h4><a id="Ref_Rn_bPageSwitch"></a>bPageSwitch - Признак режима переключения страниц</h4>
  <p>
    По умолчанию = 1. Если перед вызовом Rn.init() установить <code>Rn.bPageSwitch=0</code>,
    то переключение виртуальных страниц в Radon будет отключено и все страницы станут видимыми.
  </p>

  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_RadonObject"></a>RadonObject - Общий интерфейс базовых классов</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Ниже представлена UML-диаграмма классов, из которой следует,
    что все базовые классы, используемые системой Radon, реализуют общий интерфейс.
    Другими словами, класс RadonObject является невидимым. Невозможно создать его экземпляр. 
    Кроме того, в списке <a href="#Ref_RadonObject_parents">parents</a> этот класс тоже отсутствует.<br />
    Но все классы-наследники имеют ряд общих свойств, которые перечислены далее.
  </p>
<svg id="Diag_RadonObject" width="16.5em" height="8.1em" viewBox="0 0 330 162">
  <rect class="class-box" x="101" y="6" width="128" height="22" />
  <text class="class-text" x="165" y="22">RadonObject</text>
  <rect class="class-box" x="5" y="70" width="80" height="22" />
  <a xlink:href="#Ref_PageBase">
    <text class="class-text" x="45" y="86">PageBase</text>
  </a>
  <path class="line" d="M75 70 L81.4 63.1 M87.9 56.3 L94.4 49.5 M100.9 42.7 L107.4 35.9 L103.4 32.1 L115 28 L111.3 39.7 L107.4 35.9" />
  <rect class="class-box" x="125" y="70" width="80" height="22" />
  <a xlink:href="#Ref_FormBase">
    <text class="class-text" x="165" y="86">FormBase</text>
  </a>
  <path class="line" d="M165 70 L165 59.6 M165 49.3 L165 39 L159.5 39 L165 28 L170.5 39 L165 39" />
  <rect class="class-box" x="245" y="70" width="80" height="22" />
  <a xlink:href="#Ref_CtrlBase">
    <text class="class-text" x="285" y="86">CtrlBase</text>
  </a>
  <path class="line" d="M255 70 L248.5 63.1 M242 56.3 L235.5 49.5 M229 42.7 L222.5 35.9 L218.6 39.7 L215 28 L226.5 32.1 L222.5 35.9" />
  <rect class="class-box" x="29" y="134" width="112" height="22" />
  <a xlink:href="#Ref_ValidatorBase">
    <text class="class-text" x="85" y="150">ValidatorBase</text>
  </a>
  <path class="line" d="M85 134 L88.4 126.6 M91.9 119.2 L95.4 111.8 M98.9 104.4 L102.4 97 M105.9 89.6 L109.3 82.2 M112.8 74.8 L116.3 67.5 M119.8 60.1 L123.3 52.7 M126.8 45.3 L130.3 37.9 L125.3 35.6 L135 28 L135.2 40.2 L130.3 37.9" />
  <rect class="class-box" x="197" y="134" width="96" height="22" />
  <a xlink:href="#Ref_FilterBase">
    <text class="class-text" x="245" y="150">FilterBase</text>
  </a>
  <path class="line" d="M245 134 L241.5 126.6 M238 119.2 L234.5 111.8 M231 104.4 L227.5 97 M224 89.6 L220.6 82.2 M217.1 74.8 L213.6 67.5 M210.1 60.1 L206.6 52.7 M203.1 45.3 L199.6 37.9 L194.7 40.2 L195 28 L204.6 35.6 L199.6 37.9" />
</svg>
  
  <h4><a id="Ref_RadonObject_type"></a>type - Короткое имя класса объекта</h4>
  <pre class="signature">string type</pre>
  Сначала пример:
  <xmp>
    <div class="rn-page" data-type="MyTest" data-name="A">
      <h1>Page type = <span class="my-type"></span></h1>
    </div>
  </xmp>
  <pre class="jscript">
  function PageMyTest() {
    this.superClass = 'Base';
    this.open = function() {
      $('.my-type', this.$def).text(this.type);
    }
  }</pre>
  <p>
    В результате на странице будет заголовок: Page type = MyTest
  </p>
  Теперь пояснения:
  <ul>
    <li>
      Если указан тип страницы MyTest, то где-то в скрипте должна быть определена функция-конструктор PageMyTest.
      Иначе будет сгенерировано исключение <a href="#Err_ClassNotFound">Class not found: PageMyTest</a>.
    </li>
  </ul>
  
  <h4><a id="Ref_RadonObject_name"></a>name - имя Radon-объекта</h4>
  <pre class="signature">string name;</pre>
  <p>
    Большинство Radon-объектов регистрируется в своём владельце по имени.
    Поэтому имя должно быть уникально для владельца.<br />
    Однако, для <a href="#TxValidator">валидаторов</a> и <a href="#TxFilters">фильтров</a> имя не требуется.
  </p>
  <p>
    Рекомендуется для имён объектов использовать те же правила, что и для идентификаторов JavaScript.
    Это позволит упростить доступ из скрипта. Например:
    <pre class="jscript">
      var lastName = Rn.getPageEx('start').forms.mainForm.ctrls.lastName.val();
    </pre>
    Здесь предполагается, что в странице <b>start</b> есть форма <b>mainForm</b>, а в ней контроллер <b>lastName</b>.
  </p>
  <p>
    При объявлении Radon-объекта имя должно быть указано обязательно.
    Либо при помощи атрибута <code class="hc-attr">name</code>, либо <code class="hc-attr">data-name</code>.
    Атрибут data-name является более приоритетным, чем name.
    С точки зрения правильности структуры html, атрибут <code class="hc-attr">name</code> можно использовать в теге &lt;form&gt;,
    а в таких тегах как &lt;div&gt; или &lt;span&gt; правильнее использовать <code class="hc-attr">data-name</code>.
  </p>
  Пример:
  <xmp>
  <div class="rn-page" data-name="start">
    <form class="rn-form" name="mainForm" action="#">
      <span class="rn-ctrl" data-name="lastName" data-type="String" data-title="Фамилия"></span>
    </form>
  </div>
  </xmp>
  
  <h4><a id="Ref_RadonObject_superClass"></a>superClass - имя родительского класса</h4>
  <pre class="signature">string superClass;</pre>
  <p>
    Это свойство обязательно указывается при создании класса-наследника.
    Допустим, нужно сделать специальный контроллер для ввода email.
    Для этого можно создать класс-наследник <a href="#Ref_CtrlString">CtrlString</a>:
  </p>
  <pre class="jscript">
 Rn.Ctrl.Email = function() {
	this.superClass = 'String';
	this.input_type = 'email';
 }
  </pre>
  
  <h4><a id="Ref_RadonObject_parents">parents - список предков класса</a></h4>
  <pre class="signature">Array&lt;String&gt; parents;</pre>
  Вот, например, чему равно значение поля parents для экземпляров <a href="#Ref_CtrlPassword">CtrlPassword</a>:
  <pre class="jscript">["Password", "String", "Value", "Base"]</pre>
  <p>
    parents[0] всегда равен значению поля <a href="#Ref_RadonObject_type">type</a>.
    А последний элемент всегда равен "Base".
  </p>
  
  <h4><a id="Ref_RadonObject_Sdef"></a>$def - Элемент-описатель</h4>
  <pre class="signature">jQuery $def;</pre>
  <p>
    Любой Radon-объект создаётся из html-описания. А через свойство $def можно обратиться к этому описанию.
  </p>
  Допустим, есть следующее описание:
  <xmp>
  <div class="rn-page" data-name="start" data-type="MyPage" data-title="Demo Page">
    <button>Push!</button>
  </div>
  </xmp>
  Чтобы добавить обработчик события кнопки, пишем код внутри метода onInit:
  <pre class="jscript">
function PageMyPage() {
	this.superClass = 'Base';
	this.onInit = function() {
		this.$def.find('button').click(function(){
			alert('Hello!');
			return false;
		});
	}
}
  </pre>

  <h4><a id="Ref_RadonObject_onInit"></a>onInit() - сообщение об инициализации системы</h4>
  <pre class="signature">void onInit();</pre>
  <p>
    Вызывается сразу после инициализации системы.
  </p>

  <h4><a id="Ref_RadonObject_onOpen"></a>onOpen() - сообщение об открытии страницы</h4>
  <pre class="signature">void onOpen();</pre>
  <p>
    Вызывается в случае открытия страницы.
    Срабатывает при вызове <a href="#Ref_Rn_activate">Rn.activate()</a>.
  </p>

  <h4><a id="Ref_RadonObject_onClose"></a>onClose() - сообщение о закрытии страницы</h4>
  <pre class="signature">void onClose();</pre>
  <p>
    Вызывается в случае закрытия страницы.
    Срабатывает при вызове <a href="#Ref_Rn_activate">Rn.activate()</a>.
  </p>

  <h4><a id="Ref_RadonObject_onUpdate"></a>onUpdate() - сообщение об изменениях в системе</h4>
  <pre class="signature">void onUpdate();</pre>
  
  <h4><a id="Ref_RadonObject_onReset"></a>onReset - Событие сброса объекта</h4>
  <pre class="signature">void onReset()</pre>
  <p>
    Устанавливает для объекта значение по-умолчанию.
    Обычно, имеет смысл для контроллеров, но может быть переопределён для страниц и форм.<br />
    Действует только на свой объект.<br />
    Напрямую не вызывается. Чтобы инициировать сброс объекта, нужно пользоваться <a href="#Ref_RadonObject_reset">reset()</a>.
  </p>
  
  <h4><a id="Ref_RadonObject_reset"></a>reset() - Выполнить сброс указанного объекта.</h4>
  <pre class="signature">void reset()</pre>
  <p>
    Выполняет сброс себя и всех подчинённых объектов.
    Реализуется через <a href="#Ref_Rn_reset">Rn.reset(object)</a>.<br />
    В итоге для каждого объекта иерархии вызывается <a href="#Ref_RadonObject_onReset">onReset</a> (если есть у объекта).
  </p>
  
  <h4><a id="Ref_RadonObject_load"></a>load() - Загрузка данных</h4>
  <pre class="signature">void load(Object srcObj)</pre>
  <p>
    Обновляет только указанные элементы. 
    Если нужна полная перезагрузка структуры, то перед <code>load()</code> нужно вызывать <a href="#Ref_RadonObject_reset">reset()</a>.
  </p>
  <p>
    После загрузки данных необходимо обновить состояние системы, например, при помощи <a href="#Ref_Rn_update">Rn.update()</a>.
    Но рекомендуется вместо прямого обращения к методу load Radon-объектов использовать <a href="#Ref_Rn_load">Rn.load()</a>,
    который автоматически обновляет состояние системы после загрузки.
  </p>
  <p>
    См. также: <a href="#Ref_PageBase_load">PageBase.load()</a>, <a href="#Ref_FormBase_load">FormBase.load()</a>.
  </p>
  
  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_Visitor"></a>Visitor - Объект для обхода содержимого Radon-объектов</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Каждый Radon-объект имеет функцию <code>walk(visitor)</code>.
    Это способ обхода иерархической структуры без использования циклов.
    Параметром такой функции является визитор.
    Ниже перечислены возможные свойства визитора, которые будут вызваны в определённой ситуации.
    Все свойства являются необязательными. 
    Каждый конкретный визитор содержит только те свойства, которые необходимы.
  </p>
  <h4><a id="Ref_Visitor_result"></a>result - Результат поиска</h4>
  <p>
    Как только result принимает любое значение, являющееся логической истиной, обход останавливается.
  </p>
  Пример. Поиск контроллера по его DOM-элементу.<br />
  Причём, в качестве owner может выступать страница, форма или контроллер.
  <pre class="jscript">
  function findCtrlByDef(owner, $def) {
      var visitor = {
          ctrlBegin: function(ctrl) {
              if (ctrl.$def[0] == $def[0])
                  visitor.result = ctrl;
          }
      }
      owner.walk(visitor);
      return visitor.result;
  }
  </pre>
  
  <h4><a id="Ref_Visitor_pageBegin"></a>pageBegin - Начало страницы</h4>
  <pre class="signature">void pageBegin(PageBase page)</pre>
  
  <h4><a id="Ref_Visitor_pageEnd"></a>pageEnd - Конец страницы</h4>
  <pre class="signature">void pageEnd(PageBase page)</pre>
  
  <h4><a id="Ref_Visitor_formBegin"></a>formBegin - Начало формы</h4>
  <pre class="signature">void formBegin(FormBase form)</pre>
  
  <h4><a id="Ref_Visitor_formEnd"></a>formEnd - Конец формы</h4>
  <pre class="signature">void formEnd(FormBase form)</pre>
  
  <h4><a id="Ref_Visitor_ctrlBegin"></a>ctrlBegin - Начало контроллера</h4>
  <pre class="signature">void ctrlBegin(CtrlBase ctrl)</pre>
  <p>
    Реализуется в <a href="#Ref_CtrlBase_walk">CtrlBase.walk()</a>,
    а так же в <a href="#Ref_CtrlGroup_walk">CtrlGroup.walk()</a>
    и в методах walk любых других контроллеров-агрегаторов.
  </p>
  
  <h4><a id="Ref_Visitor_ctrlEnd"></a>ctrlEnd - Конец контроллера</h4>
  <pre class="signature">void ctrlEnd(CtrlBase ctrl)</pre>
  <p>
    Реализуется в <a href="#Ref_CtrlBase_walk">CtrlBase.walk()</a>,
    а так же в <a href="#Ref_CtrlGroup_walk">CtrlGroup.walk()</a>
    и в методах walk любых других контроллеров-агрегаторов.
  </p>
  
  <h4><a id="Ref_Visitor_validator"></a>validator - Валидатор</h4>
  <pre class="signature">void validator(ValidatorBase v)</pre>
  
  <h4><a id="Ref_Visitor_filter"></a>filter - Фильтр</h4>
  <pre class="signature">void filter(FilterBase f)</pre>
  
  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_PageBase"></a>PageBase - Базовый класс страницы</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Все <a href="#TxPage">страницы</a> в системе Radon являются экземплярами либо класса PageBase, либо его наследников.
  </p>
  
  <h4><a id="Ref_PageBase_title"></a>title - Заголовок страницы</h4>
  <p>
    При отсутствии атрибута <code class="hc-attr">data-title</code> в теге-описателе страницы, заголовок читается из тега &lt;H1&gt;.
  </p>
  
  <h4><a id="Ref_PageBase_forms"></a>forms - Словарь форм</h4>
  <pre class="signature">Object&lt;string,FormBase&gt; forms</pre>
  <p>
    Словарь для получения форм, зарегистрированных в странице, по имени.
  </p>

  <h4><a id="Ref_PageBase_onInit"></a>onInit() - событие создания страницы</h4>
  <pre class="signature">void onInit()</pre>
  <p>
    Вызывается один раз после создания страницы.
    Для класса PageBase этот метод пуст. Может быть полностью переопределён в наследниках.
  </p>
  <p>
    Этот метод следует переопределить, если нужно добавить какие-либо обработчики событий для элементов внутри страницы.
  </p>
  
  <h4><a id="Ref_PageBase_onOpen"></a>onOpen() - Событие активации страницы</h4>
  <pre class="signature">void onOpen()</pre>
  <p>
    Вызывается при открытии страницы. Это происходит либо при вызове <a href="#Ref_Rn_activate" class="coderef">Rn.activate()</a>,
    либо при смене URL в браузере.
    В том числе, при нажатии на кнопки навигации назад и вперёд.<br />
    Для класса PageBase этот метод пуст. Может быть полностью переопределён в наследниках.
  </p>
  <p>
    Функция onOpen вызывается при каждой активации страницы.
    Поэтому в ней не стоит выполнять операции, связанные с подготовкой страницы к работе 
    (например, прикреплять к элементам обработчики событий). Для этого служит <a href="#Ref_PageBase_onInit">onInit()</a>.
  </p>
  
  <h4><a id="Ref_PageBase_onClose"></a>onClose() - Событие закрытия страницы</h4>
  <pre class="signature">void onClose()</pre>
  <p>
    Вызывается для текущей страницы при вызове <a href="#Ref_Rn_activate">Rn.activate()</a>
  </p>

  <h4><a id="Ref_PageBase_save"></a>save - Сохранение данных</h4>
  <pre class="signature">Object save(Object dstObj=null, boolean bSubmit=false)</pre>
  
  <h4><a id="Ref_PageBase_load"></a>load() - Загрузка данных</h4>
  <pre class="signature">void load(Object srcObj)</pre>
  <p>
    Выполняет загрузку данных страницы.
    Реализует метод интерфейса <a href="#Ref_RadonObject_load">RadonObject.load()</a><br />
    scrObj должен включать подчинённые объекты с ключами, соответствующими именам форм.
  </p>
  <p>
    Важно помнить, что load загружает только те данные, которые переданы. Для такой структуры данных:
    <pre>{ form1: {ctrl1: "Hello!"} }</pre>
    будет заполнен только контроллер ctrl1 (Если на странице есть форма form1, а в ней контроллер ctrl1).
    Остальные элементы структуры останутся неизменными.<br />
    Если нужна полная перезагрузка системы, то перед вызовом <code>load()</code> вызывайте <a href="#Ref_PageBase_reset">reset()</a>.
  </p>
  Пример:
  <xmp>
    <div class="rn-page" data-name="start">
      <form class="rn-form" name="form1" action="">
        <div class="rn-ctrl" data-name="ctrl1" data-type="String" data-title="First"></div>
        <div class="rn-ctrl" data-name="ctrl2" data-type="String" data-title="Second"></div>
      </form>
    </div>
    <script id="TmCtrlString" type="text/html">
      <div>
        {{title}}: <input type="text" name="{{name}}"/>
      </div>
    </script>
  </xmp>
  <pre class="jscript">
  Rn.curPage().load({
    form1: {
      ctrl1: "Hello,",
      ctrl2: "world!"
    }
  });
  </pre>
  Результат:
  <div class="space">
    <div>First: <input type="text" name="ctrl1" value="Hello," readonly /></div>
    <div>Second: <input type="text" name="ctrl2" value="world!" readonly /></div>
  </div>

  <h4><a id="Ref_PageBase_autoFocus"></a>autoFocus() - Установить фокус на контроллер, имеющий свойство autofocus</h4>
  <pre class="signature">void autoFocus()</pre>
  <p>
    Эта функция автоматически вызывается при открытии страницы.
    После вызова <a href="#Ref_RadonObject_onOpen">onOpen</a> всех элементов страницы.
  </p>
  <p>
    Выполняется поиск видимого контроллера, имеющего признак <a href="#Ref_CtrlBase_autofocus">autofocus</a>.
    Если найден, то для него вызывается функция <a href="#Ref_CtrlBase_focus">focus()</a>.
  </p>

  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_FormBase"></a>FormBase - Базовый класс формы</h3>
  <!-- ------------------------------------------------------ -->
  
  <h4><a id="Ref_FormBase_Ssubmit"></a>$submit - Кнопка сабмита формы</h4>
  <pre class="signature">jQuery $submit;</pre>
  <p>
    jQuery-объект, представляющий кнопку сабмита формы.
    Пример описания:
    <xmp><input type="submit" class="rn-submit" value="Применить" /></xmp>
    В принципе, главное здесь - класс rn-submit. А элемент может быть любым.
  </p>
  
  <h4><a id="Ref_FormBase_ok"></a>ok - Статус формы</h4>
  <pre class="signature">boolean ok;</pre>
  <p>
    Статус формы. Меняется при вызове <a href="#Ref_Rn_update">update</a>. Если 0(false), то сабмит запрещён.<br />
    Устанавливается внутри <a href="#Ref_FormBase_postUpdate">postUpdate()</a>.
  </p>
  <p>
    Может быть использовано внутри <a href="#Ref_FormBase_onPostUpdate">onPostUpdate()</a>,
    если нужно выполнить что-то только в случае успешного состояния формы.
  </p>

  <h4><a id="Ref_FormBase_data_src"></a>data_src - Источник данных для загрузки при инициализации</h4>
  <pre class="signature">string data_src;</pre>
  <p>
    Это необязательное свойство. Если указать имя переменной в глобальной области, то
    внутри метода <a href="#Ref_FormBase_onInit">onInit()</a> произойдёт загрузка данных из указанного источника.
  </p>
  <p>
    Метод <a href="#Ref_FormBase_autoStore">autoStore()</a> вызывается после <a href="#Ref_FormBase_onInit">onInit()</a>.
    Поэтому следует учесть, что если использованы свойства session_key или storage_key,
    то они затрут данные, загруженные из data_src.  </p>
  Пример:
  <xmp>
    <form class="rn-form" name="person" action="#" data-data_src="g_persData">
      <div class="rn-ctrl" data-name="name" data-type="String" data-title="Имя"></div>
      <div class="rn-ctrl" data-name="email" data-type="String" data-title="Эл.почта"></div>
    </form>
  </xmp>
  JavaScript:
  <pre class="jscript">
    var g_persData = {
      name: "James Bond",
      email: "james.bond@site.net"
    };
  </pre>
  Форма после инициализации будет выглядеть примерно так:
  <div class="rn-ctrl">
    <span class="title">Имя</span>
    <input type="text" name="name" value="James Bond" />
  </div>
  <div class="rn-ctrl">
    <span class="title">Эл.почта</span>
    <input type="text" name="email" value="james.bond@site.net" />
  </div>

  <h4><a id="Ref_FormBase_onSubmit"></a>onSubmit() - Событие сабмита формы.</h4>
  <pre class="signature">void onSubmit()</pre>
  <p>
    Базовый класс формы выводит содержимое формы в виде JSON-объекта.
    Наследники переопределяют этот метод.
  </p>
  <p>
    Если для формы любым способом будет определено свойство <code>result=true</code>, то произойдёт реальный сабмит формы.
    Конечно, если форма описана через тег <code>&lt;form ...&gt;</code>.
    В остальных случаях событие сабмита перехватывается сиcтемой Radon и не обрабатывается браузером.
  </p>
  
  <h4><a id="Ref_FormBase_reset"></a>reset() - Сброс формы</h4>
  <pre class="signature">void reset()</pre>
  <p>
    Реализация интрефейсного метода <a href="#Ref_RadonObject_reset">RadonObject.reset()</a>.<br />
    Вызывает <a href="Ref_Rn_reset">Rn.reset(this)</a>, а тот уже вызывает <a href="Ref_RadonObject_onReset">onReset()</a>
    для данной формы и всех её контроллеров.
  </p>
  
  <h4><a id="Ref_FormBase_onReset"></a>onReset - Событие сброса формы</h4>
  <pre class="signature">void onReset()</pre>
  <p>
    Срабатывает при вызове <a href="#Ref_RadonObject_reset">reset()</a> или <a href="#Ref_Rn_reset">Rn.reset()</a> для страницы или формы.<br />
    Не содержит никакой реализации.<br />
    Предполагается, что может быть переопределён в классах, наследуемых от FormBase для совершения каких-то действий в момент сброса формы.<br />
    Вызывается до того, как будут вызваны события onReset подчинённых контроллеров.
  </p>
  
  <h4><a id="Ref_FormBase_load"></a>load() - Загрузка данных формы из указанного объекта</h4>
  <pre class="signature">void load(Object srcObj);</pre>
  <p>Является реализацией <a href="#Ref_RadonObject_load">RadonObject.load()</a>.</p>
  <p>
    Объект srcObj обычно содержит пары ключ-значение.
    Но в общем случае каждый контроллер сам определяет способ чтения данных из объекта.
  </p>
  
  <h4><a id="Ref_FormBase_save"></a>save() - Запись данных в объект</h4>
  <pre class="signature">Object save(Object dstObj=undefined, bool bSubmit=false)</pre>
  <p>
    Записывает в объект значения всех контроллеров формы.
  </p>
  <p>
    Если установлен bSubmit, то данные фильтруются.
  </p>

  <h4><a id="Ref_FormBase_onInit"></a>onInit() - Инициализация формы</h4>
  <pre class="signature">void onInit()</pre>
  <p>
    Является реализацией метода <a href="#Ref_RadonObject_onInit">RadonObject.onInit()</a>.<br />
    Имеет следующее поведение:
    при наличии свойства <a href="#Ref_FormBase_data_src">data_src</a> выполняет загрузку данных при помощи
    <a href="#Ref_FormBase_load">load()</a>.
  </p>
  <p>
    В случае переопределения этого метода в классах-наследниках, нужно вызывать метод родительского класса.
  </p>
  
  <h4><a id="Ref_FormBase_autoStore"></a>autoStore() - Автоматическое сохранение и загрузка данных формы</h4>
  <pre class="signature">void autoStore(boolean bLoad);</pre>
  <p>
    Метод вызывается автоматически. Может быть переопределён.<br />
    Вызов c bLoad происходит сразу после инициализации формы.
    Вызов без bLoad происходит после <a href="#Ref_FormBase_postUpdate">postUpdate()</a>.
  </p>
  <p>
    Стандартное поведение:
    Если в свойствах формы указаны storage_key или session_key, то сохранение происходит в обоих случаях.
    А загрузка в первую очередь из сессии(session), далее из локального хранилища(storage).
  </p>
  <p>
    Конечно, функции загрузки и сохранения различны. Но объединены в одну из-за их взаимного соответствия,
    чтобы нельзя было переопределить одну и забыть другую.
  </p>
  
  <h4><a id="Ref_FormBase_onUpdate"></a>onUpdate() - Сообщение об изменениях системы</h4>
  <p>
    Этот метод является реализацией <a href="#Ref_RadonObject_onUpdate">RadonObject.onUpdate()</a>.
    Он пуст, поэтому его можно переопределять без вызова Base_onUpdate().
  </p>
  <p>
    Вызывается раньше, чем onUpdate подчинённых контроллеров формы.
  </p>
  
  <h4><a id="Ref_FormBase_onPostUpdate"></a>onPostUpdate() - Сообщение об изменении системы, вызываемое после проверок</h4>
  <pre class="signature">void onPostUpdate();</pre>
  <p>
    Событие, которое вызывается после <a href="#Ref_Rn_update">update</a>.
    Причём, перед ним срабатывают все <a href="#Ref_RadonObject_onUpdate">onUpdate()</a> и выполняется проверка формы
    при помощи <a href="#Ref_FormBase_postUpdate">postUpdate()</a>.
  </p>
  <p>
    Внутри метода можно пользоваться свойством <a href="#Ref_FormBase_ok">ok</a>.<br />
    Метод базового класса пуст, поэтому его можно переопределять без вызова FormBase_onPostUpdate().
  </p>
  
  <h4><a id="Ref_FormBase_postUpdate"></a>postUpdate() - Действия, выполняемые после обновления формы</h4>
  <pre class="signature">protected void postUpdate();</pre>
  <p>
    Внутренняя функция. Срабатывает в результате <a href="#Ref_Rn_update">Rn.update()</a>.
    Причём, все <a href="#Ref_RadonObject_onUpdate">onUpdate</a> вызываются до этого метода. 
    Внутри метода срабатывают check() <a href="#Ref_FormBase_check">формы</a> и <a href="#Ref_CtrlBase_check">контроллеров</a>,
    а так же <a href="#Ref_CtrlBase_onError">onError()</a>, <a href="#Ref_FormBase_enableSubmit">enableSubmit()</a>
    и <a href="#Ref_FormBase_onPostUpdate">onPostUpdate()</a>.
  </p>

  <h4><a id="Ref_FormBase_check"></a>check() - Проверка формы</h4>
  <pre class="signature">void check(Array errList)</pre>
  <p>
    Общая проверка формы. Вызывается после валидации всех контроллеров.<br/>
    Переопределяется наследниками, чтобы добавить проверки, не связанные с каким-то контроллером.
  </p>
  <p>
    В случае обнаружения ошибки нужно выполнить: errList.push( {msg:'Сообщение'} )
  </p>
  
  <h4><a id="Ref_FormBase_enableSubmit"></a>enableSubmit() - Разрешение или запрет кнопки сабмита</h4>
  <pre class="signature">void enableSubmit(boolean bEnable);</pre>
  <p>
  Запрет кнопки сабмита используется для предотвращения повторной отправки формы.
  Рекомендуется вызывать внутри onSubmit, если принято решение обработать форму.
  Следует учесть, что как только вызовется Rn.update, состояние будет автоматически установлено по результатам валидации формы.
  </p>
  <p>
    Обращается к <a href="#Ref_Rn_enable">Rn.enable()</a>.
  </p>
  
  <h4><a id="Ref_FormBase_onCtrlError"></a>onCtrlError() - Отображение ошибок контроллера</h4>
  <pre class="signature">void onCtrlError(CtrlBase ctrl, string msg)</pre>
  <p>
    Если (!msg), значит ошибок нет. Иначе msg является строкой с сообщением об ошибке.
  </p>
  <p>
    Предполагается, что каждая форма может централизованно определять механизм отображения ошибок.
    Поэтому переопределение этого метода для объекта формы повлияет на поведение всех подчинённых контроллеров.
  </p>
  <p>
    Стандартное поведение состоит в том, что для <a href="#Ref_RadonObject_Sdef">ctrl.$def</a> назначается (или снимается)
    класс .invalid (<a href="#Ref_Rn_props_clsInvalid">Rn.props.clsInvalid</a>) и атрибуту <code class="hc-attr">title</code>
    назначается сообщение msg (или пустая строка, если ошибки нет).
    В этом случае DOM-структура описателя контроллера в случае ошибки выглядит примерно так:
    <xmp>
    <div class="rn-ctrl invalid" title="Ошибка!" ... ></div>
    </xmp>
  </p>
  <p>
    Система Radon не предлагает никакого готового решения по формированию внешнего вида элементов.
    Эти вопросы должен решать вебмастер. Но ножно привести примеры.
  </p>
  
  Самым простым решением может послужить изменение фона элемента-описателя. Для этого можно определить такое правило:
  <pre class="css">.rn-ctrl.invalid { background-color:#FDD; }</pre>
  И выглядит это будет так:
  <div class="rn-ctrl">
      <span class="title">Фамилия</span>
      <input type="text" value="Иванов" />
  </div>
  <div class="rn-ctrl" style="background-color:#FDD" title="Необходимо ввести имя">
    <span class="title">Имя</span>
    <input type="text" />
  </div>
  <p>
    Возможно, это не самый удачный дизайн. Кроме того, выделения цветом недостаточно, так как пользователь может иметь дефекты зрения.
    Взамен можно предложить более сложные правила, тем не менее, всё в рамках CSS:
  </p>
  <pre class="css">
  .rn-ctrl.invalid .title::before {
     content:"!"; position:absolute;
     width:1.2em; height:1.2em; display:inline-block; margin-left:-1.5em;
     border-radius:0.6em; background-color:#C00; color:white;
     text-align:center; font-weight:bold;}</pre>
  <style>
    .rn-ctrl.err-demo2 .title::before { content:"!"; position:absolute;
     width:1.2em; height:1.2em; display:inline-block; margin-left:-1.5em;
     border-radius:0.6em; background-color:#C00; color:white;
     text-align:center; font-weight:bold;
     }

  </style>
  <div class="rn-ctrl err-demo2" title="Необходимо ввести имя">
    <span class="title">Имя</span>
    <input type="text" />
  </div>
  
  <p>
    Возможно, потребуется выдавать сообщение об ошибке напротив каждого контроллера.
    К сожалению, здесь не обойтись без модификации шаблонов контроллеров.
    Вот пример такого шаблона для <a href="#Ref_CtrlString">CtrlString</a>
  </p>
  <xmp>
  <div>
    <span class="title">{{title}}</span>
    <span class="right-part">
      <input type="text" name="{{name}}" />
      <div class="err-msg"></div>
    </span>
  </div>
  </xmp>
  
  
  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_CtrlBase"></a>CtrlBase - Базовый класс контроллера</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Общая концепция контроллеров рассматривается в разделе <a href="#TxCtrl">Описание контроллеров</a>.
  </p>
  <h5><a id="Ref_CtrlBase_Diagram"></a>Диаграмма классов-наследников базового контроллера</h5>

<svg id="Diag_CtrlBase" width="18.8em" height="12.9em" viewBox="0 0 376 258">
  <rect class="class-box" x="125" y="6" width="80" height="22" />
  <text class="class-text selected" x="165" y="22">Base</text>
  <rect class="class-box" x="25" y="70" width="80" height="22" />
  <a xlink:href="#Ref_CtrlGroup">
    <text class="class-text" x="65" y="86">Group</text>
  </a>
  <path class="line" d="M95 70 L127.4 35.9 L123.4 32.1 L135 28 L131.3 39.7 L127.4 35.9" />
  <rect class="class-box" x="125" y="70" width="80" height="22" />
  <a xlink:href="#Ref_CtrlValue">
    <text class="class-text" x="165" y="86">Value</text>
  </a>
  <path class="line" d="M165 70 L165 39 L159.5 39 L165 28 L170.5 39 L165 39" />
  <rect class="class-box" x="225" y="70" width="80" height="22" />
  <a xlink:href="#Ref_CtrlArray">
    <text class="class-text" x="265" y="86">Array</text>
  </a>
  <path class="line" d="M235 70 L202.5 35.9 L198.6 39.7 L195 28 L206.5 32.1 L202.5 35.9" />
  <rect class="class-box" x="125" y="166" width="80" height="22" />
  <a xlink:href="#Ref_CtrlString">
    <text class="class-text" x="165" y="182">String</text>
  </a>
  <path class="line" d="M165 166 L165 103 L159.5 103 L165 92 L170.5 103 L165 103" />
  <rect class="class-box" x="5" y="134" width="80" height="22" />
  <a xlink:href="#Ref_CtrlDroplist">
    <text class="class-text" x="45" y="150">Droplist</text>
  </a>
  <path class="line" d="M75 134 L125.9 98.3 L122.8 93.8 L135 92 L129.1 102.8 L125.9 98.3" />
  <rect class="class-box" x="245" y="134" width="80" height="22" />
  <a xlink:href="#Ref_CtrlRadiobox">
    <text class="class-text" x="285" y="150">Radiobox</text>
  </a>
  <path class="line" d="M255 134 L204 98.3 L200.8 102.8 L195 92 L207.1 93.8 L204 98.3" />
  <rect class="class-box" x="35" y="166" width="80" height="22" />
  <a xlink:href="#Ref_CtrlCheckbox">
    <text class="class-text" x="75" y="182">Checkbox</text>
  </a>
  <path class="line" d="M110 166 L144.7 101.6 L139.9 99 L150 92 L149.6 104.2 L144.7 101.6" />
  <rect class="class-box" x="215" y="166" width="80" height="22" />
  <a xlink:href="#Ref_CtrlHidden">
    <text class="class-text" x="255" y="182">Hidden</text>
  </a>
  <path class="line" d="M220 166 L185.2 101.6 L180.3 104.2 L180 92 L190 99 L185.2 101.6" />
  <rect class="class-box" x="225" y="230" width="80" height="22" />
  <a xlink:href="#Ref_CtrlText">
    <text class="class-text" x="265" y="246">Text</text>
  </a>
  <path class="line" d="M230 230 L193 195.5 L189.2 199.5 L185 188 L196.7 191.4 L193 195.5" />
  <rect class="class-box" x="125" y="230" width="80" height="22" />
  <a xlink:href="#Ref_CtrlPassword">
    <text class="class-text" x="165" y="246">Password</text>
  </a>
  <path class="line" d="M165 230 L165 199 L159.5 199 L165 188 L170.5 199 L165 199" />
  <rect class="class-box" x="259" y="6" width="112" height="22" />
  <a xlink:href="#Ref_RadonObject">
    <text class="class-text" x="315" y="22">RadonObject</text>
  </a>
  <path class="line" d="M205 17 L213.6 17 M222.2 17 L230.8 17 M239.4 17 L248 17 L248 11.5 L259 17 L248 22.5 L248 17" />
</svg>
  
  <!-- =========================== -->
  <h4><a id="Ref_CtrlBase_form"></a>form - Форма, которой принадлежит контроллер</h4>
  <pre class="signature">FromBase form;</pre>
  <p>
    Свойство позволяет обратиться к <a href="#TxForm">форме</a>-владельцу контроллера.
  </p>
  <p>
    Но следует учитывать, что для обращения к непосредственному владельцу контроллера служит свойство <a href="#Ref_CtrlBase_owner">owner</a>.<br />
    Рассмотрим следующий пример:
  </p>
  <xmp>
  <form class="rn-form" name="form1" action="#">
    <div class="rn-ctrl" data-name="station" data-type="Group">
      <div class="rn-ctrl" data-name="name" data-type="String" data-title="Название"></div>
    </div>
  </form>
  </xmp>
  <p>
  Здесь представлены два контроллера: station (тип <a href="#Ref_CtrlGroup">Group</a>) и name (тип <a href="#Ref_CtrlString">String</a>).<br />
  Оба контроллера содержат свойство <b>form</b>, которое указывает на форму form1.
  Для контроллера station свойство owner совпадает со свойством form, так как он зарегистрирован непосредственно внутри формы.
  А вот у контроллера name свойство owner будет указывать на station.
  </p>
  <!-- =========================== -->
  <h4><a id="Ref_CtrlBase_owner"></a>owner - Владелец контроллера</h4>
  <p>
    Владельцем контроллера может быть либо <a href="#TxForm">форма</a>,
    либо контроллер-агрегатор такой как <a href="#Ref_CtrlGroup">CtrlGroup</a>.
    В обоих случаях можно обращаться к соседним контроллерам через конструкцию
    <pre class="jscript">
    this.owner.ctrls.fieldName
    </pre>
    Это может потребоваться внутри функции <a href="#Ref_CtrlBase_onUpdate">onUpdate()</a>,
    а так же из <a href="#TxValidator">валидаторов</a> и <a href="#TxFilters">фильтров</a>.
  </p>
  <p>
    Также см. <a href="#Ref_CtrlBase_form">CtrlBase.form</a>.
  </p>
  
  
  <!-- =========================== -->
  <h4><a id="Ref_CtrlBase_title"></a>title - Название поля</h4>
  <p>
    Не является обязательным свойством, но широко используется в шаблонах контроллеров.
  </p>
  Например, есть следующее описание:
  <xmp>
  <div class="rn-ctrl" data-name="lastName" data-type="String" data-title="Фамилия"></div>
  </xmp>
  Здесь значение свойства title указано атрибутом <code class="hc-attr">data-title</code>.
  Но оно используется лишь в шаблоне контроллера, который может выглядеть так:
  <xmp>
  <script id="TmCtrlString" type="text/html">
    <div>
      <span class="title">{{title}}</span>:
      <input type="text" name="{{name}}" />
    </div>
  </script>
  </xmp>
  Что в результате даёт примерно такой внешний вид:
  <div class="space">
    <span>Фамилия</span>: <input type="text" />
  </div>
  <p>
    Впрочем, возможен и другой вариант шаблона, полезный в тех случаях, когда форма должна выглядеть как можно более компактно:
  </p>
  <xmp>
  <script type="text/html" id="TmCtrlString">
    <input type="text" name="{{name}}" placeholder="{{title}}" />
  </script>
  </xmp>
  Что выглядит так:
  <div class="space">
    <input type="text" placeholder="Фамилия" />
  </div>
  
  <!-- =========================== -->
  <h4><a id="Ref_CtrlBase_value0"></a>value0 - Значение по-умолчанию</h4>
  <p>
    Необязательный параметр. Содержит значение по-умолчанию, которое подставляется при вызове <a href="#Ref_CtrlBase_reset">reset()</a>.
  </p>

  <!-- =========================== -->
  <h4><a id="Ref_CtrlBase_autofocus"></a>autofocus - Признак контроллера, который автоматически получает фокус при открытии страницы</h4>
  <p>
    Необязательный параметр. Если установлен в 1 или true, то контроллер получит фокус при открытии страницы.
    При условии, что контроллер видимый.
  </p>
  <p>
    Предполагается, что на странице существует не более одного такого контроллера.
    <br/>
    См. <a href="#Ref_PageBase_autoFocus">PageBase.autoFocus()</a>.
  </p>

  <!-- =========================== -->
  <h4><a id="Ref_CtrlBase_update"></a>update() - Обновить состояние системы после внесения изменений</h4>
  <pre class="signature">void update()</pre>
  <p>
    Если контроллер находится на активной странице, то вызывается <a href="#Ref_Rn_update">Rn.update()</a>.
    А если нет, то обновление произойдёт, когда страница станет активной.
  </p>

  <!-- =========================== -->
  <h4><a id="Ref_CtrlBase_onUpdate"></a>onUpdate() - Событие, вызванное изменением состояния системы</h4>
  <pre class="signature">void onUpdate()</pre>
  <p>
    Этот метод является реализацией интерфейса <a href="#Ref_RadonObject_onUpdate">RadonObject.onUpdate()</a>.
    Не выполняет никаких действий.
    Поэтому его можно полностью переопределять в классах-наследниках. Обращение к Base_onUpdate() не требуется.
  </p>
  
  <!-- =========================== -->
  <h4><a id="Ref_CtrlBase_reset"></a>reset() - Сбросить значение контроллера</h4>
  <p>
    Сервисная функция, которая вызывает <a href="#Ref_Rn_reset">Rn.reset()</a>, 
    а из него вызывается <a href="#Ref_CtrlBase_onReset">onReset()</a>.
    Не переопределяется, т.к. для переопределения служит <a href="#Ref_CtrlBase_onReset">onReset()</a>.
  </p>
  
  <!-- =========================== -->
  <h4><a id="Ref_CtrlBase_onReset"></a>onReset() - Событие cброса значения контроллера</h4>
  <pre class="signature">void onReset()</pre>
  <p>
    Переопределяемая функция, которая выполняет сброс значения для каждого конкретного типа контроллеров.
  </p>

  <!-- =========================== -->
  <h4><a id="Ref_CtrlBase_load"></a>load() - Загрузка данных</h4>
  <pre class="signature">void load(Object srcObj)</pre>
  <p>
    Функция полностью переопределяется наследниками класса CtrlBase, т.к. каждый тип контроллера может иметь свой формат данных.<br />
    Контроллер должен предполагать, что параметр srcObj может содержать что угодно. То есть, необходимо убедиться, что это объект.<br />
    После загрузки необходимо вызвать <a href="#Ref_CtrlBase_update">update()</a> или <a href="#Ref_Rn_update">Rn.update()</a>,
    т.к. необходимо отобразить полученные изменения.
  </p>
  
  <!-- ============================ -->
  <h4><a id="Ref_CtrlBase_save"></a>save() - Сохранение данных</h4>
  <pre class="signature">Object save(Object dstObj={}, boolean bSubmit=false)</pre>
  <p>
    Функция полностью переопределяется наследниками класса CtrlBase, т.к. каждый тип контроллера может иметь свой формат данных.<br />
    Параметр <b>bSubmit</b> определяет, нужна ли фильтрация сохраняемых значений.
    Кроме того, если <b>bSubmit</b> установлен, то невидимые контроллеры не записывают своё содержимое.
  </p>
  Пример реализации:
  <pre class="jscript">
  function CtrlDemo() {
    var value=0;
    ...
    this.save = function(dstObj, bSubmit) {
      dstObj = dstObj || {};
      dstObj[this.name] = value;
      return dstObj;
    }
  }
  </pre>
  
  <!-- ============================ -->
  <h4><a id="Ref_CtrlBase_val"></a>val() - Получение простого значения</h4>
  <pre class="signature">mixed val()</pre>
  <p>
    Эта функция удобна для получения значений простых контроллеров: <a href="#Ref_CtrlString">CtrlString</a>,
    <a href="#Ref_CtrlDropbox">CtrlDropbox</a> и т.п.<br />
    Результат зависит от особенностей реализации контроллера. Например, CtrlString возвращает строку.<br />
    Переопределять эту функцию в наследуемых классах не требуется.
    Реализация функции val() является универсальной за счёт использования функции <a href="#Ref_CtrlBase_save">save()</a>.<br />
    Возвращаемое значение не подвергается фильтрации, т.к. save() вызывается без признака bSubmit
  </p>

  <!-- ============================ -->
  <h4><a id="Ref_CtrlBase_filter"></a>filter() - Фильтрация данных</h4>
  <pre class="signature">void filter(Object dstObj)</pre>
  <p>
    Выполняет <a href="#TxFilters">фильтрацию</a> данных для указанного объекта с использованием фильтров, принадлежащих контроллеру.
  </p>
  <p>
    Этот метод вызывается из <a href="#Ref_CtrlBase_save">save()</a>, если указан параметр bSubmit=true.<br />
  </p>
  <p>Напрямую этот метод обычно не вызывается. Переопределения в наследниках не требует.</p>
  
  <!-- ============================ -->
  <h4><a id="Ref_CtrlBase_check"></a>check() - Валидация контроллера</h4>
  <pre class="signature">string check(Array errList)</pre>
  <p>
    Если выявлены неправильные данные, то возможно два варианта:
    <ol>
      <li>Через return вернуть текст сообщения об ошибке.</li>
      <li>Добавить объект ошибки непосредственно в массив: errList.push( {msg:'Сообщение', ctrl:this} ).</li>
    </ol>
  </p>
  <p>
     Если контроллер видимый, то вызывается функция <a href="#Ref_ValidatorBase_check">check()</a>
     для всех валидаторов. Если какой-либо валидатор возвращает сообщение об ошибке, то другие не проверяются.
  </p>
  <p>
    Обычно метод не переопределяется, т.к. расширение функциональности контроллера происходит путём агрегирования валидаторов.
    Однако, в случае переопределения необходимо проверять видимость контроллера при помощи <a href="#Ref_CtrlBase_isVisible">isVisible()</a>.
    Кроме того, возможно потребуется переопределить <a href="#Ref_CtrlBase_isRequired">isRequired()</a>,
    так как базовый контроллер обращается только к валидаторам.
    Если внутри функции check() происходит проверка на обязательное заполнение,то метод isRequired() должен вернуть true.
  </p>
  
  <!-- ============================ -->
  <h4><a id="Ref_CtrlBase_onError"></a>onError() - Отображение наличия или отсутствия ошибки</h4>
  <pre class="signature">void onError(string msg)</pre>
  <p>
    Отображение наличия или отсутствия ошибки. Если ошибки нет, msg=0. Иначе - строка.
  </p>
  <p>
    Стандартное отображение ошибки предполагает централизованный механизм. 
    Поэтому данный метод обращается к <a href="#Ref_FormBase_onCtrlError">FormBase.onCtrlError(this, msg)</a>.
    Это позволяет определить общий механизм для всей формы.
  </p>
  <p>
    Стандартное поведение состоит в добавлении класса .invalid (<a href="#Ref_Rn_props_clsInvalid">Rn.props.clsInvalid</a>)
    к элементу-описателю контроллера (<a href="#Ref_RadonObject_Sdef">$def</a>).
  </p>

  <!-- ============================ -->
  <h4><a id="Ref_CtrlBase_isRequired"></a>isRequired() - Является ли элемент обязательным для заполнения</h4>
  <pre class="signature">boolean isRequired()</pre>
  <p>
    Чтобы определить, является ли элемент обязательным для заполнения, вызывается валидация пустой строки.
  </p>

  <!-- ============================ -->
  <h4><a id="Ref_CtrlBase_makeRequired"></a>makeRequired() - Признак поля, обязательного для заполнения</h4>
  <p>
   Установить (или снять) визуальный признак того, что элемент обязателен для заполнения.
   Автоматически вызывается после каждого <a href="#Ref_CtrlBase_onUpdate">onUpdate()</a>.
  </p>
  <p>
    Стандартное поведение состоит в том, чтобы установить для элемента-описателя <a href="#Ref_RadonObject_Sdef">$def</a>
    установить класс rn-required (точнее, название класса указано свойством <a href="#Rn_props_clsRequired">Rn.props.clsRequired</a>).<br />
    Это может использоваться для визуального отображения. Общепринятая практика состоит в том, чтобы 
    название поля, обязательного для заполнения, было отмечено красной звёздочкой. Примерно вот так:
    <div>
      <span>Название</span><span style="color:red; margin-right:1em;">*</span> <input type="text" />
    </div>
    Для этого можно использовать следующее CSS-правило:
    <pre class="css">.rn-ctrl.rn-required .title::after {content:"*"; color:#F00;}</pre>
    Здесь используется класс .title, который напрямую не относится к системе Radon. Но рекомендуемые шаблоны контроллеров
    содержат имена полей {{title}}, снабжённые этим классом.
  </p>
  <!-- ============================ -->
  <h4><a id="Ref_CtrlBase_show"></a>show() - Показать или скрыть контроллер</h4>
  <pre class="signature">void show(boolean bOn)</pre>
  
  <!-- ============================ -->
  <h4><a id="Ref_CtrlBase_isVisible"></a>isVisible() - Виден ли контроллер</h4>
  <pre class="signature">boolean isVisible()</pre>

  <h4><a id="Ref_CtrlBase_render"></a>render - Генерация DOM-содержимого контроллера</h4>
  <pre class="signature">jQuery render()</pre>

  <p>
    Имеет следующую реализацию:<br/>
    Сначала вычисляется идентификатор шаблона при помощи <a href="#Ref_Rn_findTm">Rn.findTm()</a>.<br/>
    Затем генерируется содержимое контроллера при помощи <a href="#Ref_Rn_tm">Rn.tm()</a>.
  </p>
  <p>
    Возвращает jQuery-объект для сгенерированного содержимого.
    Обычно этот результат игнорируется.
  </p>
  <p>
    Обычно наследники переопределяют функцию рендера, но с вызовом функции родительского класса.
  </p>

  <!-- ============================ -->
  <h4><a id="Ref_CtrlBase_focus"></a>focus() - Установить фокус на контроллер</h4>
  <pre class="signature">void focus()</pre>
  <p>
    Если в составе контроллера есть свойство <a href="#Ref_CtrlValue_Sedit">$edit</a>,
    то для него вызывается jQuery-функция focus().<br/>
    Для остальных контроллеров нужно переопределять функцию.
  </p>

  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_ValidatorBase"></a>ValidatorBase - Базовый валидатор</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Концепция валидаторов рассматривается в разделе <a href="#TxValidator">Описание валидаторов</a>.
  </p>
  <h5>Диаграмма классов</h5>
  <svg id="Diag_ValidatorBase" width="22.4em" height="8.74em" viewBox="0 0 448 174.8">
    <rect class="class-box" x="197" y="6" width="80" height="22" />
    <text class="class-text selected" x="237" y="22">Base</text>
    <rect class="class-box" x="331" y="6" width="112" height="22" />
    <a xlink:href="#Ref_RadonObject">
      <text class="class-text" x="387" y="22">RadonObject</text>
    </a>
    <path class="line" d="M277 17 L285.6 17 M294.2 17 L302.8 17 M311.4 17 L320 17 L320 11.5 L331 17 L320 22.5 L320 17" />
    <rect class="class-box" x="5" y="89.2" width="104" height="22" />
    <a xlink:href="#Ref_ValidatorNonEmpty">
      <text class="class-text" x="57" y="105.2">NonEmpty</text>
    </a>
    <path class="line" d="M92 89.2 L192.3 33.3 L189.7 28.5 L202 28 L195 38.1 L192.3 33.3" />
    <rect class="class-box" x="147" y="102" width="80" height="22" />
    <a xlink:href="#Ref_ValidatorRegexp">
      <text class="class-text" x="187" y="118">Regexp</text>
    </a>
    <path class="line" d="M187 102 L221.7 37.6 L216.9 35 L227 28 L226.6 40.2 L221.7 37.6" />
    <rect class="class-box" x="247" y="102" width="80" height="22" />
    <a xlink:href="#Ref_ValidatorInteger">
      <text class="class-text" x="287" y="118">Integer</text>
    </a>
    <path class="line" d="M287 102 L252.2 37.6 L247.3 40.2 L247 28 L257 35 L252.2 37.6" />
    <rect class="class-box" x="347" y="102" width="80" height="22" />
    <a xlink:href="#Ref_ValidatorRange">
      <text class="class-text" x="387" y="118">Range</text>
    </a>
    <path class="line" d="M362 102 L275.6 34.7 L272.2 39 L267 28 L279 30.4 L275.6 34.7" />
    <rect class="class-box" x="35" y="134" width="104" height="22" />
    <a xlink:href="#Ref_ValidatorMinLength">
      <text class="class-text" x="87" y="150">MinLength</text>
    </a>
    <path class="line" d="M92 134 L208.6 35.1 L205 30.9 L217 28 L212.1 39.3 L208.6 35.1" />
    <rect class="class-box" x="185" y="146.8" width="104" height="22" />
    <a xlink:href="#Ref_ValidatorMaxLength">
      <text class="class-text" x="237" y="162.8">MaxLength</text>
    </a>
    <path class="line" d="M237 146.8 L237 39 L231.5 39 L237 28 L242.5 39 L237 39" />
  </svg>

  <p>
    Особенностью всех валидаторов является то,
    что им не требуется имя объекта <a href="#Ref_RadonObject_name">name</a>.
  </p>
  
  <h4><a id="Ref_ValidatorBase_ctrl"></a>ctrl - Контроллер-владелец</h4>
  <pre class="signature">CtrlBase ctrl</pre>
  <p>
    Свойство, позволяющее обратиться к контроллеру, который владеет валидатором.
  </p>
  <h4><a id="Ref_ValidatorBase_msg"></a>msg - Сообщение об ошибке</h4>
  <pre class="signature">string msg</pre>
  <p>
    Сообщение об ошибке. Обычно, его нужно переопределять в описании валидатора. Например:
    <xmp>
      <div class="rn-ctrl" data-name="firstName" data-type="String">
        <span class="rn-validator" data-type="NonEmpty" msg="Необходимо ввести имя"></span>
      </div>
    </xmp>
  </p>
  
  <h4><a id="Ref_ValidatorBase_check"></a>check() - Проверка значения</h4>
  <pre class="signature">string check(value)</pre>
  <p>
	Если значение прошло проверку, возвращается 0, false, undefined или пустая строка.
	Если ошибка зафиксирована, возвращается сообщение об ошибке.
  </p>
  
  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_ValidatorNonEmpty"></a>ValidatorNonEmpty - Проверка на непустое значение</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Этот валидатор следует добавить к контроллеру, если его значение обязательно должно быть заполнено пользователем
    и не может оставаться пустым.<br />
    Обычно применяется с контроллером <a href="#Ref_CtrlString">CtrlString</a> и его потомками.
    Кроме того, может применяться с <a href="#Ref_CtrlDroplist">CtrlDroplist</a> в том случае,
    когда в списке вариантов есть элемент со значением в виде пустой строки:
    <code>{value:"", label:"НЕ ВЫБРАНО"}</code>
  </p>
  <h5>Диаграмма классов</h5>
<svg id="Diag_ValidatorNonEmpty" width="22.1em" height="1.7em" viewBox="0 0 442 34">
  <rect class="class-box" x="5" y="6" width="112" height="22" />
  <text class="class-text selected" x="61" y="22">NonEmpty</text>
  <rect class="class-box" x="171" y="6" width="80" height="22" />
  <a xlink:href="#Ref_ValidatorBase">
    <text class="class-text" x="211" y="22">Base</text>
  </a>
  <rect class="class-box" x="325" y="6" width="112" height="22" />
  <a xlink:href="#Ref_RadonObject">
    <text class="class-text" x="381" y="22">RadonObject</text>
  </a>
  <path class="line" d="M117 17 L160 17 L160 11.5 L171 17 L160 22.5 L160 17" />
  <path class="line" d="M251 17 L260 17 M269 17 L278 17 M287 17 L296 17 M305 17 L314 17 L314 11.5 L325 17 L314 22.5 L314 17" />
</svg>

  <div>Пример:</div>
  <xmp>
  <div class="rn-ctrl" data-name="lastName" data-type="String" data-title="Фамилия">
    <div class="rn-validator" data-type="NonEmpty" data-msg="Необходимо ввести фамилию"></div>
  </div>
  </xmp>
  
  <!--       ValidatorRegexp         -->
  <h3><a id="Ref_ValidatorRegexp"></a>ValidatorRegexp - Валидатор, использующий регулярное выражение.</h3>
  <p>
    Этот тип валидаторов позволяет проверять текстовые значения контроллеров при помощи регулярных выражений.
    Что такое Регулярные выражения, обсуждается в википедии или гугле.
  </p>
  <h5>Пример описания валидатора, который требует ввода только латинских букв, независимо от регистра</h5>
  <xmp>
  <div class="rn-validator" data-type="Regexp" data-regexp="/^[A-Z]*$/i"
    data-msg="Можно использовать только латинские буквы"></div>
  </xmp>
  <p>
    Здесь следует обратить внимание на квантификатор. В примере использован квантификатор *, что означает возможность ввода пустой строки.
    Если использовать квантификатор +, то контроллер станет обязательным для заполнения.<br />
    Однако, для обязательных полей рекомендуется использовать <a href="#Ref_ValidatorNonEmpty">NonEmpty</a>,
    который в списке валидаторов ставится раньше, чем Regexp.<br />
    Преимущество такой специализации состоит в том, что пользователь получит разные сообщения.
    Для пустой строки будет сообщение от валидатора NonEmpty, что необходимо заполнить данное поле.
    А если пользователь начал заполнять поле, но допустил ошибку, то будет сообщение о том, что использован неправильный формат.
  </p>
  <h5>Диаграмма классов</h5>
<svg id="Diag_ValidatorRegexp" width="21.3em" height="1.7em" viewBox="0 0 426 34">
  <rect class="class-box" x="5" y="6" width="80" height="22" />
  <text class="class-text selected" x="45" y="22">Regexp</text>
  <rect class="class-box" x="155" y="6" width="80" height="22" />
  <a xlink:href="#Ref_ValidatorBase">
    <text class="class-text" x="195" y="22">Base</text>
  </a>
  <rect class="class-box" x="309" y="6" width="112" height="22" />
  <a xlink:href="#Ref_RadonObject">
    <text class="class-text" x="365" y="22">RadonObject</text>
  </a>
  <path class="line" d="M85 17 L144 17 L144 11.5 L155 17 L144 22.5 L144 17" />
  <path class="line" d="M235 17 L244 17 M253 17 L262 17 M271 17 L280 17 M289 17 L298 17 L298 11.5 L309 17 L298 22.5 L298 17" />
</svg>
  
  <h4><a id="Ref_ValidatorRegexp_regexp"></a>regexp - описание регулярного выражения</h4>
  <pre class="signature">string|RegExp regexp;</pre>
  <p>
    Если свойство указано в html-описателе в виде атрибута <code class="hc-attr">data-regexp</code>, то это строка.
  </p>
  Пример, демонстрирующий правило для ввода шестнадцатеричных чисел:
  <xmp>
    <div class="rn-validator" data-type="Regexp" data-regexp="/^[\dA-F]*$/i"
      data-msg="Требуется шеснадцатеричное число"></div>
  </xmp>
  <p>
    Если свойство модифицируется из скрипта, то ему можно присвоить непосредственно регулярное выражение.
  </p>
  <pre class="jscript">
function ValidatorHex() {
	this.superClass = 'Regexp';
	this.regexp = /^[\dA-F]*$/i;
}
  </pre>
  <xmp><div class="rn-validator" data-type="Hex" data-msg="Требуется шеснадцатеричное число"></div></xmp>
  
  <h4><a id="Ref_ValidatorRegexp_getRegexp"></a>getRegexp() - Получить объект регулярного выражения</h4>
  <pre class="signature">RegExp getRegexp()</pre>
  <p>
    Валидатор внутри функции <a href="#Ref_ValidatorBase_check">check()</a>
    не использует напрямую свойство <a href="#Ref_ValidatorRegexp_regexp">regexp</a>, так как оно может содержать строку.
    Для получения объекта регулярного выражения используется getRegexp().
  </p>
  <p>
    Кроме того, эту функцию можно переопределить, если нужно динамически генерировать регулярное выражение.
    Например, в зависимости от состояния других контроллеров.
  </p>

  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_ValidatorInteger"></a>ValidatorInteger - Проверка целого числа</h3>
  <!-- ------------------------------------------------------ -->
  Если нужно организовать поле для ввода целого числа, то это можно сделать так:
  <xmp>
  <div class="rn-ctrl" data-name="count" data-type="String" data-title="Количество">
    <div class="rn-validator" data-type="Integer" data-msg="Требуется целое число"></div>
  </div>
  </xmp>
  
  <p>
    Данный валидатор может выдать сообщение, если поле не заполнено.
    Для этого нужно установить свойство <a href="#Ref_ValidatorInteger_required">required</a>.
    А если нужно ограничить область допустимых значений, то рекомендуется использовать в паре с <a href="#Ref_ValidatorRange">Range</a>.
  </p>
  
  <h5>Диаграмма классов</h5>
<svg id="Diag_ValidatorInteger" width="21.3em" height="1.7em" viewBox="0 0 426 34">
  <rect class="class-box" x="5" y="6" width="80" height="22" />
  <text class="class-text selected" x="45" y="22">Integer</text>
  <rect class="class-box" x="155" y="6" width="80" height="22" />
  <a xlink:href="#Ref_ValidatorBase">
    <text class="class-text" x="195" y="22">Base</text>
  </a>
  <rect class="class-box" x="309" y="6" width="112" height="22" />
  <a xlink:href="#Ref_RadonObject">
    <text class="class-text" x="365" y="22">RadonObject</text>
  </a>
  <path class="line" d="M85 17 L144 17 L144 11.5 L155 17 L144 22.5 L144 17" />
  <path class="line" d="M235 17 L244 17 M253 17 L262 17 M271 17 L280 17 M289 17 L298 17 L298 11.5 L309 17 L298 22.5 L298 17" />
</svg>
  
  <h4><a id="Ref_ValidatorInteger_required"></a>required - признак обязательного заполнения.</h4>
  <pre class="signature">boolean required=false;</pre>
  <p>
    Позволяет избавиться от включения валидатора <a href="#Ref_ValidatorNonEmpty">NonEmpty</a>, если поле обязательно для заполнения.
    Но следует учесть, что в случае совместного использования двух валидаторов можно выдавать пользователю более точное сообщение.
    Хотя для следующего примера вполне достаточно одного валидатора:
  </p>
  <xmp>
  <div class="rn-validator" data-type="Integer" data-required="1"
      data-msg="Требуется ввести целое число"></div>
  </xmp>
  

  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_ValidatorRange"></a>ValidatorRange - Проверка попадания числа в диапазон</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Это комплексный валидатор, который позволяет проверить до трёх условий:
  </p>
  <ul>
    <li>Значение является числом. Проверяется всегда.</li>
    <li>Значение не меньше указанного минимального значения. Проверяется при наличии свойства <a href="#Ref_ValidatorRange_min">min</a>.</li>
    <li>Значение не больше указанного максимального значения. Проверяется при наличии свойства <a href="#Ref_ValidatorRange_max">max</a>.</li>
  </ul>
  <h5>Пример описания валидатора для ввода количества от 1 до 100</h5>
  <xmp>
  <div class="rn-validator" data-type="Range" data-msg="Необходимо числовое значение"
    data-min="1" data-msg_min="Количество не должно быть меньше {{min}}"
    data-max="100" data-msg_max="Количество не должно быть больше {{max}}"
    ></div>
  </xmp>
  <h5>Диаграмма классов</h5>
<svg id="Diag_ValidatorRange" width="21.3em" height="1.7em" viewBox="0 0 426 34">
  <rect class="class-box" x="5" y="6" width="80" height="22" />
  <text class="class-text selected" x="45" y="22">Range</text>
  <rect class="class-box" x="155" y="6" width="80" height="22" />
  <a xlink:href="#Ref_ValidatorBase">
    <text class="class-text" x="195" y="22">Base</text>
  </a>
  <rect class="class-box" x="309" y="6" width="112" height="22" />
  <a xlink:href="#Ref_RadonObject">
    <text class="class-text" x="365" y="22">RadonObject</text>
  </a>
  <path class="line" d="M85 17 L144 17 L144 11.5 L155 17 L144 22.5 L144 17" />
  <path class="line" d="M235 17 L244 17 M253 17 L262 17 M271 17 L280 17 M289 17 L298 17 L298 11.5 L309 17 L298 22.5 L298 17" />
</svg>

  <h4><a id="Ref_ValidatorRange_msg"></a>msg - Сообщение о нечисловом значении</h4>
  <p>
    Это сообщение выдаётся функцией <a href="#Ref_ValidatorBase_check">check()</a>, если поступило нечисловое значение.
    Следует учесть, что если число должно быть целым, то лучше воспользоваться валидатором <a href="#Ref_ValidatorInteger">Integer</a>.
  </p>
  <h4><a id="Ref_ValidatorRange_min"></a>min - Минимальное значение</h4>
  <p>
    Это необязательное свойство. Если оно определено, то валидатор будет контролировать минимальное значение.
    Указанное значение считается допустимым.
  </p>
  
  <h4><a id="Ref_ValidatorRange_msg_min"></a>msg_min - Сообщение о нарушении минимально допустимого значения. </h4>
  <p>
    Используется только при наличии свойства <a href="#Ref_ValidatorRange_min">min</a>.
  </p>
  
  <h4><a id="Ref_ValidatorRange_max"></a>max - Максимальнон значение</h4>
  <p>
    Это необязательное свойство. Если оно определено, то валидатор будет контролировать максимальное значение значение.
    Указанное значение считается допустимым.
  </p>
  <h4><a id="Ref_ValidatorRange_msg_max"></a>msg_max - Сообщение о превышении максимально допустимого значения.</h4>
  <p>
    Используется только при наличии свойства <a href="#Ref_ValidatorRange_max">max</a>.
  </p>

  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_ValidatorMinLength"></a>ValidatorMinLength - Проверка минимальной длины строки</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Применяется для строк. Позволяет указать минимальную длину строки.
    Является валидатором, который делает поле обязательным для ввода.
  </p>
  <h5>Пример описания</h5>
  <xmp>
    <div class="rn-ctrl" data-name="login" data-type="String" data-title="Логин">
      <div class="rn-validator" data-type="MinLength" data-count="3"
           data-msg="Логин не может быть короче {{count}} символов"></div>
    </div>
  </xmp>
  <p>
    Для генерации сообщения используется функция <a href="#Ref_Rn_templText">Rn.templText</a>.
  </p>
  <h5>Диаграмма классов</h5>
  <svg id="Diag_ValidatorMinLength" width="21.9em" height="1.7em" viewBox="0 0 438 34">
    <rect class="class-box" x="5" y="6" width="104" height="22" />
    <text class="class-text selected" x="57" y="22">MinLength</text>
    <rect class="class-box" x="167" y="6" width="80" height="22" />
    <a xlink:href="#Ref_ValidatorBase">
      <text class="class-text" x="207" y="22">Base</text>
    </a>
    <rect class="class-box" x="321" y="6" width="112" height="22" />
    <a xlink:href="#Ref_RadonObject">
      <text class="class-text" x="377" y="22">RadonObject</text>
    </a>
    <path class="line" d="M109 17 L156 17 L156 11.5 L167 17 L156 22.5 L156 17" />
    <path class="line" d="M247 17 L256 17 M265 17 L274 17 M283 17 L292 17 M301 17 L310 17 L310 11.5 L321 17 L310 22.5 L310 17" />
  </svg>


  <h4><a id="Ref_ValidatorMinLength_count"></a>count - минимальное количество символов</h4>
  <pre class="signature">int count;</pre>
  <p>
    Валидатор считает значение контроллера правильным, если в нём содержится указанное количество символов или более.
    Например, если count=3, то "ab" - неправильно, "abc" - правильно, "abcd" - правильно.
  </p>

  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_ValidatorMaxLength"></a>ValidatorMaxLength - Проверка максимальной строки длины строки</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Применяется для строк. Позволяет указать максимальную длину строки.
  </p>
  <p>
    Возможно, данный валидатор не слишком актуален, так как максимальную длину строк можно контролировать
    свойством <a href="#Ref_CtrlString_maxlength">maxlength</a>.
    Однако, если код страницы генерируется сервером, то данный валидатор может быть полезен.
  </p>
  <h5>Пример описания</h5>
  <xmp>
    <div class="rn-ctrl" data-name="login" data-type="String" data-title="Логин">
      <div class="rn-validator" data-type="MaxLength" data-count="3"
           data-msg="Логин не может быть длиннее {{count}} символов"></div>
    </div>
  </xmp>
  <p>
    Для генерации сообщения используется функция <a href="#Ref_Rn_templText">Rn.templText</a>.
  </p>
  <h5>Диаграмма классов</h5>
  <svg id="Diag_ValidatorMaxLength" width="22em" height="1.7em" viewBox="0 0 440 34">
    <rect class="class-box" x="5" y="6" width="108" height="22" />
    <text class="class-text selected" x="59" y="22">MaxLength</text>
    <rect class="class-box" x="169" y="6" width="80" height="22" />
    <a xlink:href="#Ref_ValidatorBase">
      <text class="class-text" x="209" y="22">Base</text>
    </a>
    <rect class="class-box" x="323" y="6" width="112" height="22" />
    <a xlink:href="#Ref_RadonObject">
      <text class="class-text" x="379" y="22">RadonObject</text>
    </a>
    <path class="line" d="M113 17 L158 17 L158 11.5 L169 17 L158 22.5 L158 17" />
    <path class="line" d="M249 17 L258 17 M267 17 L276 17 M285 17 L294 17 M303 17 L312 17 L312 11.5 L323 17 L312 22.5 L312 17" />
  </svg>

  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_FilterBase"></a>FilterBase - Базовый фильтр</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Фильтры прикрепляются к контроллерам для придания им дополнитльной функциональности.<br />
    Назначение фильтров состоит в изменении содержимого сохраняемых данных функцией <a href="#Ref_CtrlBase_save">save(dstObj, true)</a>.
    Фильтрация включается в том случае, когда save() вызывается с параметром bSubmit=true.
  </p>
  <h4><a id="Ref_FilterBase_ctrl"></a>ctrl - Контроллер, владелец фильтра</h4>
  <pre class="signature">CtrlBase ctrl</pre>
  
  <h4><a id="Ref_FilterBase_filter"></a>filter() - Функция фильтра</h4>
  <pre class="signature">void filter(Object dstObj)</pre>
  <p>
    Эта функция полностью переопределяется в классах-наследниках.<br />
    Смысл функции в том, чтобы внести изменения в объект, полученный в результате выполнения функции контроллера <a href="#Ref_CtrlBase_save">save()</a>.<br />
  </p>
  Пример реализации фильтра, который меняет строковое значение на числовое. А если не удалось преобразовать строку в число, то значение удаляется из объекта.
  <pre class="jscript">
  function FilterNumDemo() {
      this.superClass = 'Base';
      this.filter = function(dstObj) {
          var name = this.ctrl.name;
          var numValue = +dstObj[name];
          if (isNaN(numValue)) {
              delete dstObj[name];  // Удалить ошибочное значение из объекта данных
          } else {
              dstObj[name] = numValue;  // Заменить прежнее значение на числовое
          }
      }
  }
  </pre>

  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_CtrlValue"></a>CtrlValue - Контроллер ввода простого значения</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Большинство контроллеров нужны для ввода простых значений - строк, чисел, дат и т.п.
    Контроллер CtrlValue служит для них общим предком.
  </p>
  <p>
    Не следует создавать контроллеры с типом Value. Данный класс является абстрактным.
    Классы-наследники должны переопределить три функции: render, dom2val, val2dom.
  </p>
  <h5>Диаграмма родственных классов</h5>
<svg id="Diag_CtrlValue" width="29.8em" height="8.1em" viewBox="0 0 596 162">
  <rect class="class-box" x="195" y="6" width="80" height="22" />
  <text class="class-text selected" x="235" y="22">Value</text>
  <rect class="class-box" x="325" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlBase">
    <text class="class-text" x="365" y="22">Base</text>
  </a>
  <path class="line" d="M275 17 L314 17 L314 11.5 L325 17 L314 22.5 L314 17" />
  <rect class="class-box" x="479" y="6" width="112" height="22" />
  <a xlink:href="#Ref_RadonObject">
    <text class="class-text" x="535" y="22">RadonObject</text>
  </a>
  <path class="line" d="M405 17 L414 17 M423 17 L432 17 M441 17 L450 17 M459 17 L468 17 L468 11.5 L479 17 L468 22.5 L468 17" />
  <rect class="class-box" x="95" y="70" width="80" height="22" />
  <a xlink:href="#Ref_CtrlCheckbox">
    <text class="class-text" x="135" y="86">Checkbox</text>
  </a>
  <path class="line" d="M155 70 L205.9 34.3 L202.8 29.8 L215 28 L209.1 38.8 L205.9 34.3" />
  <rect class="class-box" x="5" y="70" width="80" height="22" />
  <a xlink:href="#Ref_CtrlHidden">
    <text class="class-text" x="45" y="86">Hidden</text>
  </a>
  <path class="line" d="M65 70 L184.5 31.3 L182.8 26.1 L195 28 L186.2 36.6 L184.5 31.3" />
  <rect class="class-box" x="195" y="70" width="80" height="22" />
  <a xlink:href="#Ref_CtrlString">
    <text class="class-text" x="235" y="86">String</text>
  </a>
  <path class="line" d="M235 70 L235 39 L229.5 39 L235 28 L240.5 39 L235 39" />
  <rect class="class-box" x="295" y="70" width="80" height="22" />
  <a xlink:href="#Ref_CtrlDroplist">
    <text class="class-text" x="335" y="86">Droplist</text>
  </a>
  <path class="line" d="M315 70 L264 34.3 L260.8 38.8 L255 28 L267.1 29.8 L264 34.3" />
  <rect class="class-box" x="383" y="70" width="104" height="22" />
  <a xlink:href="#Ref_CtrlRadiobox">
    <text class="class-text" x="435" y="86">Radiobox</text>
  </a>
  <path class="line" d="M405 70 L285.4 31.3 L283.7 36.6 L275 28 L287.1 26.1 L285.4 31.3" />
  <rect class="class-box" x="183" y="134" width="104" height="22" />
  <a xlink:href="#Ref_CtrlPassword">
    <text class="class-text" x="235" y="150">Password</text>
  </a>
  <path class="line" d="M235 134 L235 103 L229.5 103 L235 92 L240.5 103 L235 103" />
  <rect class="class-box" x="295" y="134" width="80" height="22" />
  <a xlink:href="#Ref_CtrlText">
    <text class="class-text" x="335" y="150">Text</text>
  </a>
  <path class="line" d="M315 134 L264 98.3 L260.8 102.8 L255 92 L267.1 93.8 L264 98.3" />
</svg>
  
  <h4><a id="Ref_CtrlValue_value"></a>value - Значение контроллера</h4>
  <pre class="signature">protected mixed value;</pre>
  <p>
    Напрямую к этому свойству следует обращаться только внутри переопределяемых функций
    <a href="#Ref_CtrlValue_dom2val">dom2val()</a> и <a href="#Ref_CtrlValue_val2dom">val2dom()</a>.<br />
    В других случаях читать его, в принципе, можно. Но записывать в него нельзя, т.к. это не вызовет изменение внешнего вида контроллера.<br />
    Внешние объекты для доступа к данным контроллера используют функции
    <a href="#Ref_CtrlBase_load">load()</a>, <a href="#Ref_CtrlBase_save">save()</a> и <a href="#Ref_CtrlBase_val">val()</a>.<br />
    Внутренние функции контроллера могут использовать <a href="#Ref_CtrlValue_setValue">setValue()</a>
    и <a href="#Ref_CtrlValue_getValue">getValue()</a>.
    Обработчики событий DOM-элементов для синхронизации значения должны использовать <a href="#Ref_CtrlValue_fromDOM">fromDOM()</a>.<br />
  </p>
  
  <h4><a id="Ref_CtrlValue_Sedit"></a>$edit - DOM-элемент для редактирования значения</h4>
  <pre class="signature">jQuery $edit = null;</pre>
  <p>
    Это свойство используется некоторыми потомками класса CtrlValue, чтобы хранить элемент-редактор.
    К таким элементам относятся <code class="hc-tag">input</code>, <code class="hc-tag">select</code>
    или <code class="hc-tag">textarea</code>.
  </p>
  <p>
    Используется внутри <a href="#Ref_CtrlValue_dom2val">dom2val()</a> и <a href="#Ref_CtrlValue_val2dom">val2dom()</a>.
  </p>

  <h4><a id="Ref_CtrlValue_render"></a>render() - Генерация DOM-содержимого контроллера</h4>
  <pre class="signature">void render();</pre>
  
  <h4><a id="Ref_CtrlValue_val2dom"></a>val2dom() - Вывести значение контроллера в DOM-элемент</h4>
  <pre class="signature">protected void val2dom();</pre>
  <p>
    Если контроллер использует свойство <a href="#Ref_CtrlValue_Sedit">$edit</a>, то для него используется
    <pre class="jscript">	this.$edit.val(this.value)</pre>
    А иначе этот метод обязательно должен быть переопределён классом-наследником.
  </p>
  <p>
    Значение извлекается из свойства <a href="#Ref_CtrlValue_value">value</a> и копируется в DOM-элемент.<br />
    Напрямую метод вызывать не следует. Эффективнее вызывать <a href="#Ref_CtrlValue_setValue">setValue</a>.
  </p>
  
  <h4><a id="Ref_CtrlValue_dom2val"></a>dom2val() - Считать значение контроллера из DOM-элемента</h4>
  <pre class="signature">abstract protected void val2dom();</pre>
  <p>
    Если контроллер использует свойство <a href="#Ref_CtrlValue_Sedit">$edit</a>, то для него используется
  </p>
    <pre class="jscript"> this.value = this.$edit.val() </pre>
  <p>
    Значение извлекается из DOM-элемента и копируется в <a href="#Ref_CtrlValue_value">value</a>.<br />
    Напрямую метод вызывать не следует. Эффективнее вызывать <a href="#Ref_CtrlValue_fromDOM">fromDOM</a>.
  </p>
  
  <p>
  Но если контроллер не содержит элементов input, select или textarea, то для него нет необходимости переопределять данную функцию,
  потому что она не используется. Подробнее описано в примере <a href="#Ex_RatingBar">RatingBar</a>.
  </p>
  
  <h4><a id="Ref_CtrlValue_setValue"></a>setValue() - установить значение контроллера из скрипта</h4>
  <pre class="signature">void setValue(mixed newValue)</pre>
  <p>
	Назначить новое значение контроллера из скрипта (но не в случае изменения DOM-элемента).
	При этом обновится внешний вид контроллера и будет выполнена проверка всех форм страницы.<br />
    В основном, используется из функций <a href="#Ref_RadonObject_onUpdate">onUpdate()</a>.
  </p>
  
  <h4><a id="Ref_CtrlValue_getValue"></a>getValue() - получить значение контроллера</h4>
  <pre class="signature">mixed getValue() const</pre>
  <p>
    Этот метод создан только в качестве пары для <a href="#Ref_CtrlValue_setValue()">setValue()</a>.
    Результат точно такой же, как у базового метода <a href="#Ref_CtrlBase_val">val()</a>.
    Кроме того, значение можно прочитать напрямую из свойства <a href="#Ref_CtrlValue_value">value</a>.
  </p>
  
  <h4><a id="Ref_CtrlValue_fromDOM"></a>fromDOM() - Синхронизация данных для обработчиков событий</h4>
  <pre class="signature">protected void fromDOM()</pre>
  <p>
    Если контроллер использует DOM-элемент, который сам хранит своё значение (input, select, textarea),
    то внутри функции <a href="#Ref_CtrlBase_render">render</a> должны быть определены обработчики событий change и им подобных.
    (Смотри также <a href="#Ref_Rn_setTextHandler">Rn.setTextHandler()</a>.)
    Как только пользователь изменил состояние редактируемого элемента, необходимо синхронизировать значение DOM-элемента и контроллера.
    Для этого нужно вызвать метод fromDOM().
  </p>
  Для примера приведена реализация функции render для <a href="#Ref_CtrlDroplist">CtrlDroplist</a>:
  <pre class="jscript">
  this.render = function() {
    var ctrl = this;
    ctrl.Value_render();
    ctrl.$edit = $('select', ctrl.$def).change(function(){
      ctrl.fromDOM();
    });
    ctrl.buildList();
  }
  </pre>
  
  <p>
    Внутри fromDOM() происходит вызов метода <a href="#Ref_CtrlValue_dom2val">dom2val()</a>, который обычно переопределяется в наследуемых классах.
  </p>
  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_CtrlGroup"></a>CtrlGroup - Контроллер для объединения в группу других контроллеров</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Контроллер <b>Group</b> позволяет агрегировать другие контроллеры.
    С точки зрения структуры данных, он реализует объект.
  </p>
  Вот пример структуры данных, состоящей из двух объектов, в каждом из которых по два простых значения:
  <pre class="jscript">
{
	src: {
		country: "Russia",
		city: "Moscow"
	},
	dst: {
		country: "Thailand",
		city: "Bangkok"
	}
}
  </pre>
  А вот пример описания формы для редактирования этой структуры данных:
  <xmp>
  <form class="rn-form" name="route" action="#">
    <div class="rn-ctrl" data-name="src" data-type="Group">
      <h5>Откуда</h5>
      <div class="rn-ctrl" data-name="country" data-type="String" data-title="Страна"></div>
      <div class="rn-ctrl" data-name="city" data-type="String" data-title="Город"></div>
    </div>
    <div class="rn-ctrl" data-name="dst" data-type="Group">
      <h5>Куда</h5>
      <div class="rn-ctrl" data-name="country" data-type="String" data-title="Страна"></div>
      <div class="rn-ctrl" data-name="city" data-type="String" data-title="Город"></div>
    </div>
    <input type="submit" value="OK" />
  </form>
  </xmp>
  <h5>Диаграмма классов</h5>
<svg id="Diag_CtrlGroup" width="20.3em" height="1.7em" viewBox="0 0 406 34">
  <rect class="class-box" x="5" y="6" width="80" height="22" />
  <text class="class-text selected" x="45" y="22">Group</text>
  <rect class="class-box" x="135" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlBase">
    <text class="class-text" x="175" y="22">Base</text>
  </a>
  <rect class="class-box" x="289" y="6" width="112" height="22" />
  <a xlink:href="#Ref_CtrlRadonObject">
    <text class="class-text" x="345" y="22">RadonObject</text>
  </a>
  <path class="line" d="M85 17 L124 17 L124 11.5 L135 17 L124 22.5 L124 17" />
  <path class="line" d="M215 17 L224 17 M233 17 L242 17 M251 17 L260 17 M269 17 L278 17 L278 11.5 L289 17 L278 22.5 L278 17" />
</svg>
  <p>
    Особенность этого контроллера в том, что ему не нужен шаблон.
    Содержимое тега-описателя сохраняется.
  </p>
  <p>
    У подчинённых контроллеров свойство <a href="#Ref_CtrlBase_owner">owner</a> указывает на контроллер группы.
  </p>

  <h4><a id="Ref_CtrlGroup_walk"></a>walk() - обход содержимого контроллера</h4>
  <pre class="signature">void walk(Visitor visitor)</pre>
  Метод переопределяет <a href="#Ref_CtrlBase_walk">CtrlBase.walk()</a>
  и реализует особое поведение для группы вложенных контроллеров:
  <ul>
    <li>Сначала вызывается <a href="#Ref_Visitor_ctrlBegin">ctrlBegin</a> для контроллера группы.</li>
    <li>Затем вызываются методы <a href="#Ref_CtrlBase_walk">walk</a> для всех подчинённых контроллеров.</li>
    <li>В конце вызывается <a href="#Ref_Visitor_ctrlEnd">ctrlEnd</a> для контроллера группы.</li>
  </ul>
  
  <h4><a id="Ref_CtrlGroup_saveItems"></a>saveItems() - Сохранение значений подчинённых элементов</h4>
  <pre class="signature">void saveItems(Object subObj, boolean bSubmit)</pre>
  <p>
    Вызывается из CtrlGroup.save().
  </p>

  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_CtrlString"></a>CtrlString - Контроллер ввода строки</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Служит для ввода простых строковых значений. Является наиболее часто используемым контроллером.
    Представляет оболочку над тегом <code>&lt;input type="text" /&gt;</code>
  </p>
  Пример описания:
  <xmp>
  <div class="rn-ctrl" data-name="lastName" data-type="String" data-title="Фамилия"></div>
  </xmp>
  <h5><a id="Ref_TmCtrlString"></a>Рекомендуемый шаблон для класса CtrlString и его простых наследников</h5>
  <xmp>
  <script id="TmCtrlString" type="text/html">
    <div>
      <span class="title">{{title}}</span>
      <input type="{{input_type}}" name="{{name}}"
        {{#maxlength}}maxlength="{{maxlength}}"{{/maxlength}}
        {{#placeholder}}placeholder="{{placeholder}}"{{/placeholder}} />
    </div>
  </script>
  </xmp>
  <div class="warning">Внутри шаблона обязательно наличие тега input.</div>
  <h5>Диаграмма классов, связанных с CtrlString</h5>
<svg id="Diag_CtrlString" width="25.3em" height="4.9em" viewBox="0 0 506 98">
  <rect class="class-box" x="5" y="6" width="80" height="22" />
  <text class="class-text selected" x="45" y="22">String</text>
  <rect class="class-box" x="125" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlValue">
    <text class="class-text" x="165" y="22">Value</text>
  </a>
  <path class="line" d="M85 17 L114 17 L114 11.5 L125 17 L114 22.5 L114 17" />
  <rect class="class-box" x="245" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlBase">
    <text class="class-text" x="285" y="22">Base</text>
  </a>
  <path class="line" d="M205 17 L234 17 L234 11.5 L245 17 L234 22.5 L234 17" />
  <rect class="class-box" x="389" y="6" width="112" height="22" />
  <a xlink:href="#Ref_RadonObject">
    <text class="class-text" x="445" y="22">RadonObject</text>
  </a>
  <path class="line" d="M325 17 L332.5 17 M340.1 17 L347.7 17 M355.2 17 L362.8 17 M370.4 17 L378 17 L378 11.5 L389 17 L378 22.5 L378 17" />
  <rect class="class-box" x="5" y="70" width="80" height="22" />
  <a xlink:href="#Ref_CtrlPassword">
    <text class="class-text" x="45" y="86">Password</text>
  </a>
  <path class="line" d="M45 70 L45 39 L39.5 39 L45 28 L50.5 39 L45 39" />
  <rect class="class-box" x="105" y="70" width="80" height="22" />
  <a xlink:href="#Ref_CtrlText">
    <text class="class-text" x="145" y="86">Text</text>
  </a>
  <path class="line" d="M125 70 L74 34.3 L70.8 38.8 L65 28 L77.1 29.8 L74 34.3" />
</svg>
  
  
  <h4><a id="Ref_CtrlString_input_type"></a>input_type - Тип элемента input</h4>
  <pre class="signature">string input_type = "text"</pre>
  <p>
    Свойство input_type используется для того, чтобы указать значение атрибута <code>type</code> для элемента <code>&lt;input /&gt;</code>.<br />
    Используется шаблоном контроллера:
    <xmp><input type="{{input_type}}" ... /></xmp>
    Полезен в тех случаях, когда один шаблон используется не только для экземпляров CtrlString, но и классов-наследников.
    Например, <a href="#Ref_CtrlPassword">CtrlPassword</a> отличается лишь тем, что для него input_type="password".
  </p>
  <p>
    HTML5 предлагает довольно много типов для специальных случаев: url, number, email и т.д.
    Все их можно использовать без написания скриптового кода. Например:
    <xmp>
    <div class="rn-ctrl" data-name="count" data-type="String" data-title="Количество"
      data-input_type="number"></div>
    </xmp>
  </p>
  
  <h4><a id="Ref_CtrlString_placeholder"></a>placeholder - текст внутри поля ввода, который исчезает при получении фокуса</h4>
  <pre class="signature">string placeholder;</pre>
  <p>
    Это свойство не является частью класса. Используется только внутри <a href="#TxTempl">шаблона</a>.
    Здесь оно приводится, в качестве примера расширения функциональности контроллера без использования скрипта.
  </p>
  Пример:
  <xmp>
  <div class="rn-ctrl" data-name="msg" data-type="Text" data-rows="2"
      data-title="Сообщение" data-placeholder="Ваше сообщение"></div>
   ...
  <script id="TmCtrlText" type="text/html">
    <div>
      <div>{{title}}</div>
      <textarea name="{{name}}" cols="{{cols}}" rows="{{rows}}"
        placeholder="{{placeholder}}"></textarea>
    </div>
  </script>
  </xmp>
  Результат выглядит так:
  <div class="space">
    <div>
      <div class="title">Сообщение</div>
      <textarea name="msg" cols="60" rows="2"
        placeholder="Ваше сообщение"></textarea>
    </div>
  </div>

  <h4><a id="Ref_CtrlString_maxlength"></a>maxlength - максимальная длина вводимой строки</h4>
  <p>
    Это необязательное свойство. Не является частью класса. Полностью реализуется через шаблон.
  </p>
  Допустим есть такое описание:
  <xmp>
    <div class="rn-ctrl" data-name="login" data-type="String"
         data-maxlength="16" data-title="Логин"></div>
  </xmp>
  И такой шаблон
  <xmp>
    <script type="text/html" id="TmCtrlString">
      <div>
        <span class="title">{{title}}</span>
        <input type="text" name="{{name}}" maxlength="{{maxlength}}" />
      </div>
    </script>
  </xmp>
  В результате будет сгенерирован следующий код контроллера (внутри функции <a href="#Ref_CtrlBase_render">render</a>):
  <xmp>
    <div>
      <span class="title">Логин</span>
      <input type="text" name="login" maxlength="16" />
    </div>
  </xmp>

  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_CtrlPassword"></a>CtrlPassword - Контроллер ввода пароля</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Предназначен для ввода пароля.<br />
    Является наследником <a href="#Ref_CtrlString">CtrlString</a>.
    Полностью копирует поведение базового класса с единственным отличием:
    <a href="#Ref_CtrlString_input_type">input_type</a> = "password";
  </p>
  <h5>Диаграмма классов</h5>
  <svg id="Diag_CtrlPassword" width="33.4em" height="1.7em" viewBox="0 0 668 34">
    <rect class="class-box" x="5" y="6" width="104" height="22" />
    <text class="class-text selected" x="57" y="22">Password</text>
    <rect class="class-box" x="147" y="6" width="80" height="22" />
    <a xlink:href="#Ref_CtrlString">
      <text class="class-text" x="187" y="22">String</text>
    </a>
    <rect class="class-box" x="277" y="6" width="80" height="22" />
    <a xlink:href="#Ref_CtrlValue">
      <text class="class-text" x="317" y="22">Value</text>
    </a>
    <rect class="class-box" x="407" y="6" width="80" height="22" />
    <a xlink:href="#Ref_CtrlBase">
      <text class="class-text" x="447" y="22">Base</text>
    </a>
    <rect class="class-box" x="551" y="6" width="112" height="22" />
    <a xlink:href="#Ref_RadonObject">
      <text class="class-text" x="607" y="22">RadonObject</text>
    </a>
    <path class="line" d="M109 17 L136 17 L136 11.5 L147 17 L136 22.5 L136 17" />
    <path class="line" d="M227 17 L266 17 L266 11.5 L277 17 L266 22.5 L266 17" />
    <path class="line" d="M357 17 L396 17 L396 11.5 L407 17 L396 22.5 L396 17" />
    <path class="line" d="M487 17 L494.5 17 M502.1 17 L509.7 17 M517.2 17 L524.8 17 M532.4 17 L540 17 L540 11.5 L551 17 L540 22.5 L540 17" />
  </svg>

  <h5>Пример описания:</h5>
  <xmp>
  <div class="rn-ctrl" data-name="pass" data-type="Password" data-title="Пароль"></div>
  </xmp>
  <p>
    Не рекомендуется использовать отдельный шаблон для данного контроллера.
    Вместо этого лучше использовать шаблон <a href="#Ref_TmCtrlString">TmCtrlString</a>.
  </p>
  <p>
    Класс CtrlPassword сделан для удобства разработчиков.
    Потому что вместо него можно было бы пользоваться CtrlString с примерно следующим описанием:
    <xmp>
    <div class="rn-ctrl" data-type="String" data-input_type="password" ...></div>
    </xmp>
    Но элемент для ввода пароля удобнее выделить в отдельную категорию.
  </p>
  
  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_CtrlText"></a>CtrlText - Контроллер ввода текста</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Служит для ввода многострочного текста.
    Является аналогом тега <code>&lt;textarea&gt;</code>.
    Имеет соответствующие свойства cols и rows для определения размера области редактирования
  </p>
  Пример описания:
  <xmp>
  <div class="rn-ctrl" data-name="MyText" data-type="Text" data-cols="80" data-rows="10"
    data-title="My text"></div>
  </xmp>
  Рекомендуемый шаблон:
  <xmp>
  <script id="TmCtrlText" type="text/html">
    <div>
      <span class="title">{{title}}</span>
      <textarea name="{{name}}" cols="{{cols}}" rows="{{rows}}"></textarea>
    </div>
  </script>
  </xmp>
  <div class="warning">Обязательно наличие тега textarea внутри шаблона.</div>
  <h5>Диаграмма родительских классов:</h5>
<svg id="Diag_CtrlText" width="31.3em" height="1.7em" viewBox="0 0 626 34">
  <rect class="class-box" x="5" y="6" width="80" height="22" />
  <text class="class-text selected" x="45" y="22">Text</text>
  <rect class="class-box" x="125" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlString">
    <text class="class-text" x="165" y="22">String</text>
  </a>
  <path class="line" d="M85 17 L114 17 L114 11.5 L125 17 L114 22.5 L114 17" />
  <rect class="class-box" x="245" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlValue">
    <text class="class-text" x="285" y="22">Value</text>
  </a>
  <path class="line" d="M205 17 L234 17 L234 11.5 L245 17 L234 22.5 L234 17" />
  <rect class="class-box" x="365" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlBase">
    <text class="class-text" x="405" y="22">Base</text>
  </a>
  <path class="line" d="M325 17 L354 17 L354 11.5 L365 17 L354 22.5 L354 17" />
  <rect class="class-box" x="509" y="6" width="112" height="22" />
  <a xlink:href="#Ref_RadonObject">
    <text class="class-text" x="565" y="22">RadonObject</text>
  </a>
  <path class="line" d="M445 17 L452.5 17 M460.1 17 L467.7 17 M475.2 17 L482.8 17 M490.4 17 L498 17 L498 11.5 L509 17 L498 22.5 L498 17" />
</svg>

  <h4><a id="Ref_CtrlText_cols"></a>cols - Количество колонок</h4>
  <pre class="signature">int cols = 60;</pre>
  
  <h4><a id="Ref_CtrlText_rows"></a>rows - Количество строк</h4>
  <pre class="signature">int cols = 3;</pre>
  
  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_CtrlDroplist"></a>CtrlDroplist - Выпадающий список</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Служит для выбора значения из предлагаемого списка. 
    Является оболочкой над тегом &lt;select&gt;.
  </p>
  <p>
    Близким по функционалу является контроллер <a href="#Ref_CtrlRadiobox">Radiobox</a>.
    Они совместимы настолько, что для замены Radiobox на Droplist достаточно лишь сменить тип контроллера.
  </p>
  <h5>Пример описания</h5>
  <xmp>
  <div class="rn-ctrl" data-name="transportType" data-type="Droplist"
    data-title="Тип транспорта" data-options="TmTransportType" >
  </div>
  ...
  <select id="TmTransportType" style="display:none">
    <option value="">Не указан</option>
    <option value="A">Самолёт</option>
    <option value="T">Поезд</option>
    <option value="B">Автобус</option>
  </select>
  </xmp>
  При этом вешний вид контроллера будет примерно таким:
  <div class="space">
    <span>Тип транспорта</span>:
    <select>
      <option value="" selected>Не указан</option>
      <option value="A">Самолёт</option>
      <option value="T">Поезд</option>
      <option value="B">Автобус</option>
    </select>
  </div>
  
  <h5>Рекомендуемый шаблон</h5>
  <xmp>
<script id="TmCtrlDroplist" type="text/html">
  <div>
    <span class="title">{{title}}</span>
    <select name="{{name}}"></select>
  </div>
</script>
  </xmp>
  <div class="warning">
    Внутри шаблона обязательно должен присутствовать тег &lt;select&gt;.
  </div>
  
  <h5>Диаграмма классов</h5>
<svg id="Diag_CtrlDroplist" width="26.3em" height="1.7em" viewBox="0 0 526 34">
  <rect class="class-box" x="5" y="6" width="80" height="22" />
  <text class="class-text selected" x="45" y="22">Droplist</text>
  <rect class="class-box" x="135" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlValue">
    <text class="class-text" x="175" y="22">Value</text>
  </a>
  <rect class="class-box" x="265" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlBase">
    <text class="class-text" x="305" y="22">Base</text>
  </a>
  <rect class="class-box" x="409" y="6" width="112" height="22" />
  <a xlink:href="#Ref_RadonObject">
    <text class="class-text" x="465" y="22">RadonObject</text>
  </a>
  <path class="line" d="M85 17 L124 17 L124 11.5 L135 17 L124 22.5 L124 17" />
  <path class="line" d="M215 17 L254 17 L254 11.5 L265 17 L254 22.5 L254 17" />
  <path class="line" d="M345 17 L352.5 17 M360.1 17 L367.7 17 M375.2 17 L382.8 17 M390.4 17 L398 17 L398 11.5 L409 17 L398 22.5 L398 17" />
</svg>

  <h4><a id="Ref_CtrlDroplist_options"></a>options - Список вариантов для выбора</h4>
  <pre class="signature">string|Object options;</pre>
  <div>
    Список вариантов может быть описан несколькими способами:
  </div>
  <ul>
    <li>при помощи DOM-элемента &lt;select&gt;;</li>
    <li>при помощи скриптовой структуры данных (массив или объект).</li>
  </ul>
  <div>В первом случае описание списка может выглядеть примерно так:</div>
  <xmp>
  <div class="rn-ctrl" data-name="order" data-type="Droplist" data-options="SelOrder"></div>
  ...
  <select style="display:none" id="SelOrder">
    <option value="1">First</option>
    <option value="2">Second</option>
  </select>
  </xmp>
  А в случае прямого обращения к <a href="#Ref_Rn_buildList">Rn.buildList()</a>:
  <pre class="jscript">
  Rn.buildList({options:"SelOrder"}, callbk);
  </pre>
  <p>
    Если список задан в скрипте, то options либо содержит имя объекта в глобальном пространстве, либо непосредственно сам объект.
    Имя удобно использовать из html-описания контроллера.
    Объект удобнее указывать в том случае, когда список формируется динамически и передаётся в <a href="#Ref_Rn_buildList">Rn.buildList()</a>.
  </p>
  <p>
    Стандартная структура данных для описания элементов списка - массив объектов с полями value и label.
    Но на практике часто требуется использовать другие структуры. Поэтому есть дополнительные свойства
    <a href="#Ref_CtrlDroplist_option_value">option_value</a> и <a href="#Ref_CtrlDroplist_option_label">option_label</a>,
    которые позволяют использовать довольно разнообразные структуры.
  </p>

  <h5><a id="BuildListRules"></a>Примеры структур данных для свойства options</h5>
  <table class="ref-tbl">
  <tr>
    <th>Данные</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td>
    <pre class="jscript">
    var g_List1 = [
      { value:1, label:'First', some: 'abc' },
      { value:2, label:'Second', some: 'xyz' }
    ];
    </pre>
    </td>
    <td>
      { options: "g_List1" }
    </td>
  </tr>
  <tr>
    <td>
    <pre class="jscript">
    var g_List2 = {
      "1": "First",
      "2": "Second"
    };
    </pre>
    </td>
    <td>
      { options: "g_List2", option_value:"@", option_label:"#" }
    </td>
  </tr>
  <tr>
    <td>
    <pre class="jscript">
    var g_List3 = [
      { id: 1, name: "First", some: 'abc'},
      { id: 2, name: "Second", some: 'xyz'}
    ];
    </pre>
    </td>
    <td>
      { options: "g_List3", option_value: "id", option_label: "name" }
    </td>
  </tr>
  <tr>
    <td>
    <pre class="jscript">
    var g_List4 = {
      "1": { label: "First", some: 'abc'},
      "2": { label: "Second", some: 'xyz'}
    };
    </pre>
    </td>
    <td>
      { options: "g_List4", option_value: "@" }
    </td>
  </tr>
  </table>
  
  В описании контроллера это может выглядеть так:
  <xmp>
  <div class="rn-ctrl" data-name="order" data-type="Droplist" data-title="Порядок"
    data-options="g_List3" data-option_value="@" data-option_label="#"></div>
  </xmp>

  <h4><a id="Ref_CtrlDroplist_option_value"></a>option_value - Поле, определяющее значение элемента списка</h4>
  <pre class="signature">string option_value = "value";</pre>
  <p>
    Если для формирования списка вариантов используется скриптовый объект,
    то свойство option_value может быть использовано, чтобы указать поле сруктуры, которое содержит значение варианта.
  </p>
  <p>
    Если данное свойство не указано, то предполагается имя поля "value". Есть два специальных значения:
    <ul>
    <li>"@" - если значение определяется индексом контейнера;</li>
    <li>"#" - если элементами контейнера являются строки и они являются значениями варианта.</li>
    </ul>
  </p>
  Примеры см. в <a href="#Ref_CtrlDroplist_options">options</a>.

  <h4><a id="Ref_CtrlDroplist_option_label"></a>option_label - Поле, определяющее текст элемента списка</h4>
  <pre class="signature">string option_label = "label";</pre>
  <p>
    Если для формирования списка вариантов используется скриптовый объект,
    то свойство option_label может быть использовано, чтобы указать поле сруктуры, которое содержит текст варианта.
  </p>
  <p>
    Если данное свойство не указано, то предполагается имя поля "label". Есть два специальных значения:
    <ul>
    <li>"@" - если текст определяется индексом контейнера;</li>
    <li>"#" - если элементами контейнера являются строки и они используются как текст варианта.</li>
    </ul>
  </p>
  Примеры см. в <a href="#Ref_CtrlDroplist_options">options</a>.
  
  <h4><a id="Ref_CtrlDroplist_buildList"></a>buildList() - Построить список вариантов</h4>
  <pre class="signature">protected void buildList();</pre>
  <p>
    Это штатный метод для построения списка вариантов.
    Он вызывает <a href="#Ref_Rn_buildList">Rn.buildList()</a>.
    А для каждой полученной пары vaue-label вызывается метод <a href=#Ref_CtrlDroplist_isValidOption">isValidOption()</a>,
    чтобы отфильтровать ненужные варианты.
  </p>
  
  <h4><a id="Ref_CtrlDroplist_isValidOption"></a>isValidOption - Фильтр для формирования списка вариантов</h4>
  <pre class="signature">boolean isValidOption(mixed value, string label)</pre>
  <p>
    Эта функция вызывается из <a href="#Ref_CtrlDroplist_buildList">buildList()</a>.
    Если результат false, то данный вариант не включается в формируемый список вариантов.
  </p>
  <p>
    По-умолчанию, метод всегда возвращает true.
    Но его можно переопределить в тех ситуациях, когда требуется динамичиское перестроение списка вариантов,
    в зависимости от значений других полей формы.
  </p>
  
  <h4><a id="Ref_CtrlDroplist_createOption"></a>createOption() - Создание элемента для выпадающего списка</h4>
  <pre class="signature">void createOption(mixed value, string label, mixed itemDef)</pre>
  <p>
    Используется внутри <a href="#Ref_CtrlDroplist_buildList">buildList()</a> для создания элементов &lt;option&gt;
    и подключения к элементу &lt;select&gt;, адресуемому свойством <a href="#Ref_CtrlValue_Sedit">$edit</a>.
  </p>
  
  
  <!-- ------------------------------------------------------ -->
  <h3><a id="Ref_CtrlRadiobox"></a>CtrlRadiobox - Список радио-кнопок</h3>
  <!-- ------------------------------------------------------ -->
  <p>
    Данный контроллер служит для выбора одного значения из предлагаемых вариантов.
    Является оболочкой для HTML-элемента &lt;input type="radio"&gt;
  </p>
  <p>По функционалу данный контроллер похож на <a href="#Ref_CtrlDroplist">Droplist</a>,
    но только все варианты показаны сразу. Поэтому рекомендуется его использовать для небольших списков.<br />
    Если потребуется заменить тип контроллера с <a href="#Ref_CtrlDroplist">Droplist</a> на <b>Radiobox</b>,
    достаточно добавить свойство <a href="#Ref_CtrlRadiobox_radio_tm">radio_tm</a>.
  </p>
  <h5>Пример описания</h5>
  <xmp>
  <div class="rn-ctrl" data-name="transport" data-type="Radiobox" data-title="Транспорт"
      data-options="g_Transport" data-option_value="@" data-value0="Bus"
      data-radio_tm="TmRadioItem"></div>
  </xmp>
  Список вариантов для данного примера (JavaScript):
  <pre class="jscript">
  var g_Transport = {
    Air: { label:'Самолёт'},
    Train: { label: 'Поезд'},
    Bus: { label: 'Автобус'}
  }
  </pre>
  <h5>Приблизительный внешний вид при использовании рекомендуемых шаблонов</h5>
  <div class="space rn-ctrl">
    <span class="title">Транспорт</span>
    <div style="display:inline-block">
      <div><label><input type="radio" name="tr" value="Air" /> Самолёт</label></div>
      <div><label><input type="radio" name="tr" value="Train" /> Поезд</label></div>
      <div><label><input type="radio" name="tr" value="Bus" checked /> Автобус</label></div>
    </div>
  </div>
  
  <h5>Рекомендуемый шаблон контроллера</h5>
  <xmp>
  <script id="TmCtrlRadiobox" type="text/html">
    <div>
      <span class="title">{{title}}</span>
      <div class="rn-radiobox" style="display:inline-block"></div>
    </div>
  </script>
  </xmp>
  <p class="warning">
    Важно, чтобы внутри шаблона присутствовал контейнер для вариантов списка, отмеченный классом
    <code class="css-class">rn-radiobox</code>
  </p>
  <h5>Рекомендуемый шаблон для элемента списка</h5>
  <xmp>
  <script id="TmRadioItem" type="text/html">
    <div>
      <label><input type="radio" name="{{name}}" value="{{value}}" /> {{label}} </label>
    </div>
  </script>
  </xmp>
  <p class="warning">
    Важно, чтобы внутри шаблона присутствовал элемент &lt;input type="radio" /&gt;
  </p>
  <h5>Диаграмма классов</h5>
<svg id="Diag_CtrlRadiobox" width="26.9em" height="1.7em" viewBox="0 0 538 34">
  <rect class="class-box" x="5" y="6" width="104" height="22" />
  <text class="class-text selected" x="57" y="22">Radiobox</text>
  <rect class="class-box" x="147" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlValue">
    <text class="class-text" x="187" y="22">Value</text>
  </a>
  <rect class="class-box" x="277" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlBase">
    <text class="class-text" x="317" y="22">Base</text>
  </a>
  <rect class="class-box" x="421" y="6" width="112" height="22" />
  <a xlink:href="#Ref_RadonObject">
    <text class="class-text" x="477" y="22">RadonObject</text>
  </a>
  <path class="line" d="M109 17 L136 17 L136 11.5 L147 17 L136 22.5 L136 17" />
  <path class="line" d="M227 17 L266 17 L266 11.5 L277 17 L266 22.5 L266 17" />
  <path class="line" d="M357 17 L364.5 17 M372.1 17 L379.7 17 M387.2 17 L394.8 17 M402.4 17 L410 17 L410 11.5 L421 17 L410 22.5 L410 17" />
</svg>

  <h4><a id="Ref_CtrlRadiobox_Srbox"></a>$rbox - контейнер вариантов</h4>
  <pre class="signature">jQuery $rbox</pre>
  <p>
    jQuery-объект для DOM-элемента, который в шаблоне отмечен классом <code class="css-class">rn-radiobox</code>.
    В него вставляются варианты, сгенерированные из списка <a href="#Ref_CtrlRadiobox_options">options</a>
    при помощи шаблона, указанного свойством <a href="#Ref_CtrlRadiobox_radio_tm">radio_tm</a>.
  </p>
  
  <h4><a id="Ref_CtrlRadiobox_options"></a>options - список вариантов</h4>
  <pre class="signature">string options;</pre>
  <p>
    Название объекта, который является списком вариантов. Это может быть id тега &lt;select&gt, либо имя переменной.
    Полностью аналогичен свойству <a href="#Ref_CtrlDroplist_options">CtrlDroplist.options</a>.
  </p>
  <p>Также см. <a href="#Ref_Rn_buildList">Rn.buildList()</a>.</p>
  
  <h4><a id="Ref_CtrlRadiobox_option_value"></a>option_value - Поле, определяющее значение элемента списка</h4>
  <pre class="signature">string option_value = "value";</pre>
  <p>
    Необязательное свойство, которое определяет поле структуры, из которого берётся значение варианта,
    если <a href="#Ref_CtrlRadiobox_options">options</a> является именем переменной.
    По-умолчанию значение читается из поля <b>value</b>.<br />
    Специальное значение "@" означает, что значение является ключом структуры.
    А специальное значение "#" означает, что вместо структуры используется текстовая строка.<br />
    Полностью аналогично <a href="#Ref_CtrlDroplist_option_value">CtrlDroplist.option_value</a>.<br />
    Также см. <a href="#BuildListRules">Примеры описания структуры</a>.
  </p>
  
  <h4><a id="Ref_CtrlRadiobox_option_label"></a>option_label - Поле, определяющее текст элемента списка</h4>
  <pre class="signature">string option_label = "label";</pre>
  <p>
    Необязательное свойство, которое определяет поле структуры, из которого берётся текст варианта,
    если <a href="#Ref_CtrlRadiobox_options">options</a> является именем переменной.
    По-умолчанию значение читается из поля <b>label</b>.<br />
    Специальное значение "@" означает, что значение является ключом структуры.
    А специальное значение "#" означает, что вместо структуры используется текстовая строка.<br />
    Полностью аналогично <a href="#Ref_CtrlDroplist_option_label">CtrlDroplist.option_label</a>.<br />
    Также см. <a href="#BuildListRules">Примеры описания структуры</a>.
  </p>
  
  <h4><a id="Ref_CtrlRadiobox_radio_tm"></a>radio_tm - Шаблон для элемента списка</h4>
  <pre class="signature">string radio_tm;</pre>
  <p>
    Это обязательное свойство для контроллера <a href="#Ref_CtrlRadiobox">Radiobox</a>.
    Оно указывает шаблон, который используется для генерации вариантов.
    Используется внутри функции <a href="#Ref_CtrlRadiobox_createOption">createOption()</a>.
  </p>
  <p>
    В качестве параметров в шаблон передаётся объект контроллера, дополненный полями value и label.
    Если <a href="#Ref_CtrlRadiobox_option">option</a> является контейнером простых объектов,
    то поля этих объектов тоже попадут в параметры шаблона, но с низким приоритетом.<br />
    Например, если в структуре есть поле name, то оно будет вытеснено свойством 
    <a href="#Ref_RadonObject_name">name</a> контроллера.
  </p>
  <p>
    Внутри шаблона обязательно должен присутствовать элемент &lt;input type="radio" &gt;
    Пример шаблона:
  </p>
  <xmp>
  <div>
    <label>
      <input type="radio" name="{{name}}" value="{{value}}" />
      {{label}}
    </label>
  </div>
  </xmp>
  <p>Здесь используется свойство контроллера <a href="#Ref_RadonObject_name">name</a>,
    а также поля value и label, извлечённые из <a href="#Ref_CtrlRadiobox_options">options</a>
    внутри функции <a href="#Ref_Rn_buildList">Rn.buildList()</a>.
  </p>
  
  <h4><a id="Ref_CtrlRadiobox_createOption"></a>createOption() - Генерация варианта</h4>
  <pre class="signature">void createOption(mixed value, string label, mixed itemDef)</pre>
  <p>
    Генерирует очередной вариант, используя шаблон <a href="#Ref_CtrlRadiobox_radio_tm">radio_tm</a>.
    Если шаблон не найден, генерируется исключение с текстом:<br />
    Invalid property "radio_tm" for "<em>name</em>" controller.
  </p>
  <p>
    Сгенерированный вариант вставляется в <a href="#Ref_CtrlRadiobox_Srbox">$rbox</a>.
  </p>
  <p>Метод вызывается из <a href="#Ref_CtrlRadiobox_buildList">buildList()</a>.
    Является аналогом <a href="#Ref_CtrlDroplist_createOption">Droplist.createOption()</a>.
  </p>
  
  <h4><a id="Ref_CtrlRadiobox_isValidOption">isValidOption() - Фильтр для формирования списка вариантов</a></h4>
  <pre class="signature">boolean isValidOption(mixed value, string label)</pre>
  <p>
    Эта функция вызывается из <a href="#Ref_CtrlRadiobox_buildList">buildList()</a>.
    Если результат false, то данный вариант не включается в формируемый список вариантов.
  </p>
  <p>
    По-умолчанию, метод всегда возвращает true.
    Но его можно переопределить в тех ситуациях, когда требуется динамичиское перестроение списка вариантов,
    в зависимости от значений других полей формы.
  </p>
  <p>
    Является аналогом <a href="#Ref_CtrlDroplist_isValidOption">Droplist.isValidOption()</a>.
  </p>
  
  <h4><a id="Ref_CtrlRadiobox_buildList"></a>buildList() - Формирование списка вариантов</h4>
  <pre class="signature">void buildList();</pre>
  <p>
    Список строится вызовом <a href="#Ref_Rn_buildList">Rn.buildList()</a>.
    Внутри функции обратного вызова вариант проверяется функцией <a href="#Ref_CtrlRadiobox_isValidOption">isValidOption()</a>.
    В случае положительного результата вариант генерируется методом <a href="#Ref_CtrlRadiobox_createOption">createOption()</a>.
  </p>
  <p>
    Является аналогом <a href="#Ref_CtrlDroplist_buildList">Droplist.buildList()</a>.
  </p>

  <h3><a id="Ref_CtrlHidden"></a>CtrlHidden - Невидимое поле</h3>
  <p>
    Является аналогом элемента <code>&lt;input type="hidden" ... /&gt;</code>.
    Имеет смысл в тех случаях, когда форма получает какие-то данные с сервера, которые нужно отправить обратно без изменения.
  </p>
  <p>
    Данный контроллер не использует шаблон. Но он сам создаёт элемент hidden, который доступен через свойство <a href="#Ref_CtrlValue_Sedit">$edit</a>.
    Поэтому, совместим с классическими формами.
  </p>
  <p>
    Обычно, значение устанавливается в описании при помощи свойства <a href="#Ref_CtrlBase_value0">value0</a>.
    Кроме того, может меняться скриптом через вызов <a href="#Ref_CtrlValue_setValue">setValue()</a>.
  </p>
  <h5>Диаграмма классов</h5>
<svg id="Diag_CtrlHidden" width="26.3em" height="1.7em" viewBox="0 0 526 34">
  <rect class="class-box" x="5" y="6" width="80" height="22" />
  <text class="class-text selected" x="45" y="22">Hidden</text>
  <rect class="class-box" x="135" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlValue">
    <text class="class-text" x="175" y="22">Value</text>
  </a>
  <rect class="class-box" x="265" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlBase">
    <text class="class-text" x="305" y="22">Base</text>
  </a>
  <rect class="class-box" x="409" y="6" width="112" height="22" />
  <a xlink:href="#Ref_RadonObject">
    <text class="class-text" x="465" y="22">RadonObject</text>
  </a>
  <path class="line" d="M85 17 L124 17 L124 11.5 L135 17 L124 22.5 L124 17" />
  <path class="line" d="M215 17 L254 17 L254 11.5 L265 17 L254 22.5 L254 17" />
  <path class="line" d="M345 17 L352.5 17 M360.1 17 L367.7 17 M375.2 17 L382.8 17 M390.4 17 L398 17 L398 11.5 L409 17 L398 22.5 L398 17" />
</svg>

  <h5>Пример описания</h5>
  <xmp>
    <div class="rn-ctrl" data-name="ownerId" data-type="Hidden" data-value0="516"></div>
  </xmp>

  <h3><a id="Ref_CtrlArray"></a>CtrlArray - Контроллер массива</h3>
  <p>
    Контроллер массива служит для ввода переменного количества однотипных блоков данных.
    Например, для табличных данных с фиксированным числом колонок и переменным числом строк.
  </p>
  <p>
    Достаточно подробно этот контроллер рассматривается в примере <a href="#Ex_Array">Использование контроллера Array</a>.
    Здесь в краткой форме изложены основные свойства и возможности.
  </p>
  <h5>Диаграмма классов</h5>
  <svg id="Diag_CtrlArray" width="20.3em" height="1.7em" viewBox="0 0 406 34">
    <rect class="class-box" x="5" y="6" width="80" height="22" />
    <text class="class-text selected" x="45" y="22">Array</text>
    <rect class="class-box" x="135" y="6" width="80" height="22" />
    <a xlink:href="#Ref_CtrlBase">
      <text class="class-text" x="175" y="22">Base</text>
    </a>
    <rect class="class-box" x="289" y="6" width="112" height="22" />
    <a xlink:href="#Ref_RadonObject">
      <text class="class-text" x="345" y="22">RadonObject</text>
    </a>
    <path class="line" d="M85 17 L124 17 L124 11.5 L135 17 L124 22.5 L124 17" />
    <path class="line" d="M215 17 L224 17 M233 17 L242 17 M251 17 L260 17 M269 17 L278 17 L278 11.5 L289 17 L278 22.5 L278 17" />
  </svg>

  <h5>Пример описания</h5>
  <xmp>
    <div class="rn-ctrl" data-name="addr" data-type="Array" data-title="Адреса"
         data-item_tm="TmAddrItem" data-min="1" data-max="3"></div>
  </xmp>
  <p>
    Здесь указано обязательное свойство <a href="#Ref_CtrlArray_item_tm">item_tm</a>.
    И необязательные свойства <a href="#Ref_CtrlArray_min">min</a> и <a href="#Ref_CtrlArray_max">max</a>.
  </p>
  <h5>Рекомендуемый шаблон</h5>
  <xmp>
    <script id="TmCtrlArray" type="text/html">
      <div>
        {{title}}:
        <div class="rn-array"></div>
        <button type="button" class="rn-add-item">Добавить элемент</button>
      </div>
    </script>
  </xmp>
  <div class="warning">
    Обязательно наличие элемента, помеченного классом <span class="css-class">rn-array</span>.
    В него добавляются элементы массива, генерируемые из шаблона <a href="#Ref_CtrlArray_item_tm">item_tm</a>.
    Название этого класса можно перенастроить при помощи <a href="#Ref_Rn_props_clsArray">Rn.props.clsArray</a>.
  </div>
  <p>
    Кнопка с классом <span class="css-class">rn-add-item</span> не является обязательной.
    Она служит для добавления новых элементов в массив. Тег элемента не имеет значения, важен только класс.
    Атрибут <code>type="button"</code> добавляется только для тега <span class="hc-tag">&lt;button/&gt;</span>,
    чтобы эта кнопка не вызывала сабмит формы.
    Название класса можно перенастроить при помощи <a href="#Ref_Rn_props_clsArrayAdd">Rn.props.clsArrayAdd</a>.
  </p>

  <h4><a id="Ref_CtrlArray_item_tm"></a>item_tm - Шаблон элемента</h4>
  <pre class="signature">string item_tm;</pre>
  <p>
    Это обязательное свойство указывает шаблон, который используется для генерации элемента массива.
    Если оно не указано, то при генерации первого элемента внутри метода <a href="#Ref_CtrlArray_addItem">addItem()</a>
    будет сгенерировано исключение: Item template is not specified for <i>name</i>.
  </p>
  <p>
    Допустим, элемент массива включает два поля: имя и фамилия. Для него шаблон может быть описан так:
  </p>
  <xmp>
    <script id="TmArrayItem" type="text/html">
      <div>
        <div class="rn-ctrl" data-name="firstName" data-type="String" data-title="Имя"></div>
        <div class="rn-ctrl" data-name="lastName" data-type="String" data-title="Фамилия"></div>
        <button type="button" class="rn-del-item">Удалить</button>
      </div>
    </script>
  </xmp>
  <p>
    Соответственно, для данного примера свойство item_tm должно быть равно "TmArrayItem";
  </p>
  <p>
    Элемент с классом <span class="css-class">rn-del-item</span> служит для удаления элемента.
    Тег элемента не имеет значения, важен только класс. Название класса ножно перенастроить через
    <a href="#Ref_Rn_props_clsArrayDel">Rn.props.clsArrayDel</a>.
  </p>

  <h4><a id="Ref_CtrlArray_min"></a>min - Минимальное число элементов</h4>
  <pre class="signature">int min = 0;</pre>
  <p>
    Если указано минимальное количество элементов, то при создании контроллера, они будут добавлены автоматически.
    Кнопки удаления (rn-del-item) <a href="#Ref_Rn_enable">разрешены</a> только в том случае, когда количество элементов больше минимального.
  </p>
  <p>
    Контроллер не обращается к данному свойству напрямую, а использует метод <a href="#Ref_CtrlArray_getMin">getMin()</a>.
  </p>

  <h4><a id="Ref_CtrlArray_max"></a>max - Максимальное число элементов</h4>
  <pre class="signature">int max = 0;</pre>
  <p>
    Если не указано или равно 0, значит нет ограничений на количество элементов.
  </p>
  <p>
    Кнопка добавления (rn-add-item) <a href="#Ref_Rn_enable">запрещается</a>, если число элементов
    достигает максимального значения.
  </p>
  <p>
    Контроллер не обращается к данному свойству напрямую, а использует метод <a href="#Ref_CtrlArray_getMin">getMax()</a>.
  </p>

  <h4><a id="Ref_CtrlArray_items"></a>items - Массив элементов</h4>
  <pre class="signature">array items;</pre>
  <p>
    Это внутреннее свойство класса. Оно представляет массив контроллеров типа <a href="#Ref_CtrlGroup">Group</a>.
    Нельзя напрямую модифицировать данный массив. Необходимо пользоваться методами
    <a href="#Ref_CtrlArray_addItem">addItem</a> и <a href="#Ref_CtrlArray_delItem">delItem</a>.
  </p>

  <h4><a id="Ref_CtrlArray_Sarray"></a>$array - контейнер для элементов массива</h4>
  <pre class="signature">jQuery $array;</pre>

  <h4><a id="Ref_CtrlArray_Sadd"></a>$add - Кнопка добавления нового элемента</h4>
  <pre class="signature">jQuery $add;</pre>


  <h4><a id="Ref_CtrlArray_getMin"></a>getMin() - Минимальное число элементов</h4>
  <pre class="signature">int getMin();</pre>
  <p>
    Базовая реализация метода возвращает значение свойства <a href="#Ref_CtrlArray_min">min</a>.
    Но наследники могут переопределить его, если нужно менять значение, в зависимости от каких-то условий.
  </p>

  <h4><a id="Ref_CtrlArray_getMax"></a>getMax() - Максимальное число элементов</h4>
  <pre class="signature">int getMax();</pre>
  <p>
    Базовая реализация метода возвращает значение свойства <a href="#Ref_CtrlArray_max">max</a>.
    Но наследники могут переопределить его, если нужно менять значение, в зависимости от каких-то условий.
  </p>

  <h4><a id="Ref_CtrlArray_addItem"></a>addItem() - Добавление нового элемента в конец массива</h4>
  <pre class="signature">void addItem()</pre>
  <p>
    Элемент не добавляется, если достигнуто максимальное количество (см. <a href="#Ref_CtrlArray_getMax">getMax()</a>).
  </p>

  <h4><a id="Ref_CtrlArray_delItem"></a>delItem() - Удаление указанного элемента массива</h4>
  <pre class="signature">void delItem(int index);</pre>
  <p>
    Параметр index - Индекс удаляемого элемента.
  </p>

  <!-- *************************************************** 
       Примеры
       *************************************************** -->
  <h2><a id="Examples"></a>Примеры</h2>
  <p>
    Вашему вниманию предлягается ряд примеров, иллюстрирующих возможности системы Radon.
    Здесь приводятся только описания задач и рассматриваются их решения.
  </p>
  <p class="examples-ref">
    Действующие демонстрации приводятся в <a href="./rn-examples/index.htm">Сборнике примеров</a>.
  </p>
  
  <!-- ****************** RatingBar ************************* -->
  
  <h3><a id="Ex_RatingBar"></a>Контроллер RatingBar</h3>
  <p>
    Рассмотрим код контроллера, который позволяет выставлять оценку от 1 до 5.
    Аналогичный контроллер присутствует среди стандартных в Android SDK.<br />
    Выглядит он примерно так:
  </p>
  <style>
	.rating-bar { border:thin solid silver; padding: 0.4em; display:inline-block; }
	.rating-star { display:inline-block; width:1.8em; height:1.8em; margin:0.1em; cursor:pointer; }
	.rating-star path {fill:#AAA;}
	.rating-star.active path { fill:#FF0; stroke:#AA0; stroke-width:1; }
	.rating-star:hover path{fill:#CCC;}
	.rating-star.active:hover path { fill:#FFC; }
  </style>
  <script type="text/javascript">
  function setRating(n) {
    var cls, i, elem = document.getElementById("RatingValue");
    elem.innerHTML = n;
    for (i=1; i<=5; i++) {
      cls="rating-star";
      if (i<=n) cls += ' active';
      elem = document.getElementById('Rating'+i);
      elem.setAttribute('class', cls);
    }
  }
  </script>
  <div class="rating-bar">
    <span class="rating-star active" id="Rating1" onclick="setRating(1)">
      <svg width="100%" height="100%" viewBox="0 0 20 20">
        <path d="M10 1 L12.4 6.8 L18.6 7.2 L13.8 11.2 L15.3 17.3 L10 14 L4.7 17.3 L6.2 11.2 L1.4 7.2 L7.6 6.8 z"/>
      </svg>
    </span>
    <span class="rating-star active" id="Rating2" onclick="setRating(2)">
      <svg width="100%" height="100%" viewBox="0 0 20 20">
        <path d="M10 1 L12.4 6.8 L18.6 7.2 L13.8 11.2 L15.3 17.3 L10 14 L4.7 17.3 L6.2 11.2 L1.4 7.2 L7.6 6.8 z"/>
      </svg>
    </span>
    <span class="rating-star active" id="Rating3" onclick="setRating(3)">
      <svg width="100%" height="100%" viewBox="0 0 20 20">
        <path d="M10 1 L12.4 6.8 L18.6 7.2 L13.8 11.2 L15.3 17.3 L10 14 L4.7 17.3 L6.2 11.2 L1.4 7.2 L7.6 6.8 z"/>
      </svg>
    </span>
    <span class="rating-star" id="Rating4" onclick="setRating(4)">
      <svg width="100%" height="100%" viewBox="0 0 20 20">
        <path d="M10 1 L12.4 6.8 L18.6 7.2 L13.8 11.2 L15.3 17.3 L10 14 L4.7 17.3 L6.2 11.2 L1.4 7.2 L7.6 6.8 z"/>
      </svg>
    </span>
    <span class="rating-star" id="Rating5" onclick="setRating(5)">
      <svg width="100%" height="100%" viewBox="0 0 20 20">
        <path d="M10 1 L12.4 6.8 L18.6 7.2 L13.8 11.2 L15.3 17.3 L10 14 L4.7 17.3 L6.2 11.2 L1.4 7.2 L7.6 6.8 z"/>
      </svg>
    </span>
  </div>
  Оценка: <span id="RatingValue">3</span>
  <p class="examples-ref">
    Действующая реализация представлена в <a href="./rn-examples/RatingBar.htm">Сборнике примеров</a>.
  </p>
  <p>
    Класс контроллера называется <b>CtrlRatingBar</b>.
    Он является наследником <a href="#Ref_CtrlValue">CtrlValue</a>, так как оперирует простым значением.
    В результате нужно реализовать лишь две функции: render и <a href="#Ref_CtrlValue_val2dom">val2dom</a>.<br />
    Обратите внимание, что функция <a href="#Ref_CtrlValue_dom2val">dom2val</a> не требуется.
    Потому что в реализации контроллера не используются элементы, обладающие собственным значением.
    А значит, нет необходимости в синхронизации.
  </p>
  CSS:
  <pre class="css">
.rating-bar { border:thin solid silver; padding: 0.4em; display:inline-block; }
.rating-star { display:inline-block; width:2em; height:2em; margin:0.1em; cursor:pointer; }
.rating-star path {fill:#AAA;}
.rating-star.active path { fill:#FF0; stroke:#AA0; stroke-width:1; }
.rating-star:hover path{fill:#CCC;}
.rating-star.active:hover path { fill:#FFC; }
  </pre>
  HTML (Шаблоны):
  <xmp>
<script id="TmCtrlRatingBar" type="text/html">
  <div class="rating-bar">
  </div>
</script>
<script id="TmRatingStar" type="text/html">
  <span class="rating-star"><svg width="100%" height="100%" viewBox="0 0 20 20">
   <path d="M10 1 L12.4 6.8 L18.6 7.2 L13.8 11.2 L15.3 17.3 L10 14 L4.7 17.3 L6.2 11.2 L1.4 7.2 L7.6 6.8 z"/>
  </svg></span>
</script>
  </xmp>
  JavaScript:
  <pre class="jscript">
function CtrlRatingBar() {
	this.superClass = "Value";
	var $bar, $stars;
	this.value = this.value0 = 1;
	this.render = function() {
		var i, ctrl = this;
		ctrl.Value_render();
		$bar = $('.rating-bar', ctrl.$def);
		for (i=0; i&lt;5; i++) {
			Rn.tm('TmRatingStar',0,$bar);
		}
		$stars = $('.rating-star', $bar).click(function(){
			ctrl.setValue($stars.index(this)+1);
			return false;
		});
		ctrl.val2dom();
		// Совместимость с классическими формами
		if (ctrl.support)
			this.$edit = $('&lt;input&gt;').attr({type:'hidden', name:ctrl.name})
				.val(this.value).appendTo(ctrl.$def);
	}
	this.val2dom = function() {
		var value = this.value;
		$stars.each(function(i){
			$(this).toggleClass('active',i&lt;value);
		});
		if (this.$edit)
			this.$edit.val(value);
	}
	this.dom2val = function() {
	}
}
  </pre>
  <!-- end of RatingBar example -->
  
  <!-- ****************** Форма ввода персональных данных ************************* -->
  <h3><a id="Ex_FormPerson"></a>Форма ввода персональных данных</h3>
  <p>
    Это достаточно объёмный пример.
    В нём рассматривается вполне реальная форма ввода персональных данных для покупки билета.
    Именно так можно оценить преимущества системы Radon.
  </p>
  <h5>Постановка задачи</h5>
  <p>
    Необходимо ввести следующую информацию с соблюдением ряда условий.
    Введенные результаты записываются в JSON-структуру для последующей отправки на сервер.
  </p>
  <table class="ref-tbl">
  <tr>
    <th>Поле</th><th>Название</th><th>Описание</th>
  </tr>
  <tr>
    <td>tariff</td><td>Тариф</td>
    <td>Один из вариантов: Полный или Детский. По умолчанию выбран Полный. Коды значений: Полный = Adult, Детский = Kid</td>
  </tr>
  <tr>
    <td>docType</td><td>Тип документа</td>
    <td>
      Возможны следующие варианты:
      <table class="ref-tbl">
      <tr>
        <th>Код</th><th>Название</th><th>Формат номера</th><th>Требования к ФИО</th>
      </tr>
      <tr>
        <td>1</td><td>Паспорт РФ</td><td>10 цифр</td><td>Только русские буквы</td>
      </tr>
      <tr>
        <td>2</td><td>Загранпаспорт</td><td>9 цифр</td><td>Только латинские буквы</td>
      </tr>
      <tr>
        <td>3</td><td>Свидетельство о рождении</td><td>Римская цифра, серия из двух русских букв и номер из 6 цифр</td>
        <td>Только русские буквы</td>
      </tr>
      <tr>
        <td>4</td><td>Другой документ</td><td>Любые символы, но не меньше одного</td>
        <td>Допустимы русские и латинские буквы</td>
      </tr>
      </table>
      По-умолчанию выбран Паспорт РФ. Код документа в запрос должен войти в виде числа.
    </td>
  </tr>
  <tr>
    <td>docNumber</td><td>Номер документа</td>
    <td>
      Строка. Поле обязательно для заполнения. Формат зависит от значения поля docType.
    </td>
  </tr>
  <tr>
    <td>lastName</td><td>Фамилия</td>
    <td>
      Строка. Поле обязательно для заполнения. Формат зависит от значения поля docType.
    </td>
  </tr>
  <tr>
    <td>firstName</td><td>Имя</td>
    <td>
      Строка. Поле обязательно для заполнения. Формат зависит от значения поля docType.
    </td>
  </tr>
  <tr>
    <td>midName</td><td>Отчество</td>
    <td>
      Строка. Поле обязательно для заполнения только для типов документа 1 и 3. Формат зависит от значения поля docType.
    </td>
  </tr>
  </table>
  Дополнительные требования:
  <ol>
    <li>
      Поля формы должны располагаться вертикально. Для каждого поля слева указано его название, а справа элемент ввода.
    </li>
    <li>
      Обязательные для заполнения поля помечаются красной звёздочкой справа от названия поля.
    </li>
    <li>
      Неправильно заполненные поля подсвечиваются бледным оттенком красного цвета, а названия полей становятся красными.
      Кроме того, ниже формы выводится текстовое описание ошибки. Если ошибок несколько, то выводится описание только первой ошибки.
      При этом, кнопка сабмита недоступна.
    </li>
    <li>
      Для удобства пользователя позволяется вводить номер документа в том виде, как он указан в оригинале документа.
      То есть, возможны следующие разделительные символы: пробел, минус и №. Но в запрос нужно отправлять номер без этих символов.
    </li>
    <li>
      Если поле docNumber заполнено неправильно,
      необходимо выводить ниже поля подсказку с форматом номера. Например, для Паспорта РФ: 12 12 123456.
    </li>
    <li>
      Если выбран детский тариф, то из списка документов необходимо исключить Паспорт РФ. 
      А если он выбран, то выбрать вместо него Свидетельство о рождении.
    </li>
    <li>
      Если выбран загранпаспорт, то поле Отчество нужно сделать невидимым и не отправлять в запрос.
    </li>
    <li>
      Если отчество не заполнено, то не отправлять его в запрос.
    </li>
  </ol>
  <h5>Эскиз формы</h5>
  <style type="text/css">
  #FormPerson { display: inline-block; border: thin silver solid;}
  #FormPerson > div { padding: 0.5em 0.3em;}
  #FormPerson .title {display:inline-block; vertical-align:top; width:10em; text-align:right; padding-right:1em;}
  #FormPerson .rn-required .title:after {content:"*"; color:#F00;}
  #FormPerson input[type=text] { width:15em;}
  #FormPerson input[type=reset], input[type=submit] { margin-left:1em; padding:0.2em 1em;}
  #FormPerson .docnum-help {font-size:80%; color:#777;}
  </style>
  <form id="FormPerson" action="#" onsubmit="return false;">
  <div>
    <span class="title">Тариф</span>
    <select name="tariff">
      <option value="Adult" selected>Полный</option>
      <option value="Kid">Детский</option>
    </select>
  </div>
  <div>
    <span class="title">Тип документа</span>
    <select name="docType">
      <option value="1">Паспорт РФ</option>
      <option value="2">Загранпаспорт</option>
      <option value="3">Свидетельство о рождении</option>
      <option value="4">Другой документ</option>
    </select>
  </div>
  <div class="rn-required">
    <span class="title">Номер документа</span>
    <span style="display:inline-block">
      <input type="text" name="docNumber" /><br />
      <span class="docnum-help">Формат номера: 12 12 123456</span>
    </span>
  </div>
  <div class="rn-required">
    <span class="title">Фамилия</span>
    <input type="text" name="lastName" />
  </div>
  <div class="rn-required">
    <span class="title">Имя</span>
    <input type="text" name="firstName" />
  </div>
  <div>
    <span class="title">Отчество</span>
    <input type="text" name="midName" />
  </div>
  <div>
    <span class="title"></span>
    <input type="submit" value="Принять" disabled />
    <input type="reset" value="Сброс" />
  </div>
  </form>
  
  <p class="examples-ref">
    Действующий образец формы представлен в <a href="./rn-examples/FormPerson.htm">Сборнике примеров</a>.
  </p>
  <p>
    Даже опытный вебмастер может столкнуться с серьёзными трудностями в процессе разработки такой формы.
    Дело в том, что сложность системы растёт экспоненциально при увеличении количества требований.<br />
    Особенно тяжело будет добиться результата, если дополнительные требования будут появляться уже в процессе
    эксплуатации готовой формы. А в реальности такое происходит очень часто.
  </p>
  <p>
    Использование системы Radon делает разработку подобной формы достаточно прогнозируемым процессом,
    доступным разработчику не слишком высокого уровня.
    Кроме того, форма остаётся достаточно гибкой и относительно легко расширяется по мере поступления новых требований.
  </p>
  
  <!-- Код -->
  <h5>HTML</h5>
  <xmp>
<div class="rn-page" data-name="start">
  <h2>Ввод персональных данных</h2>
  <form class="rn-form" name="person" data-type="Person" action="#">
    <div class="rn-ctrl" data-name="tariff" data-type="Droplist" data-value0="Adult"
      data-title="Тариф" data-options="TariffList"></div>
    <div class="rn-ctrl" data-name="docType" data-type="DocList" data-value0="1"
      data-title="Тип документа" data-options="g_DocTypes" data-option_value="@"></div>
    <div class="rn-ctrl" data-name="docNumber" data-type="String" data-title="Номер документа"
      data-tm="TmCtrlDocNumber">
      <div class="rn-validator" data-type="NonEmpty"
          data-msg="Необходимо ввести номер документа"></div>
      <div class="rn-validator" data-type="DocNumber" data-msg="Ошибка в номере документа"></div>
      <div class="rn-filter" data-type="DocNumber"></div>
    </div>
    <div class="rn-ctrl" data-name="lastName" data-type="String" data-title="Фамилия">
      <div class="rn-validator" data-type="NonEmpty" data-msg="Необходимо ввести фамилию"></div>
      <div class="rn-validator" data-type="PassName"
          data-msg="Фамилия содержит недопустимые символы"></div>
    </div>
    <div class="rn-ctrl" data-name="firstName" data-type="String" data-title="Имя">
      <div class="rn-validator" data-type="NonEmpty" data-msg="Необходимо ввести имя"></div>
      <div class="rn-validator" data-type="PassName"
          data-msg="Имя содержит недопустимые символы"></div>
    </div>
    <div class="rn-ctrl" data-name="midName" data-type="String" data-title="Отчество">
      <div class="rn-validator" data-type="NonEmptySometime"
          data-msg="Необходимо ввести отчество"></div>
      <div class="rn-validator" data-type="PassName"
          data-msg="Отчество содержит недопустимые символы"></div>
      <div class="rn-filter" data-type="NonEmpty"></div>
    </div>
    <div>
      <span class="title"></span>
      <input class="rn-submit" type="submit" value="Принять" />
      <input class="rn-reset" type="reset" value="Сброс" />
    </div>
    <div class="err-msg"></div>
  </form>
  <div id="Result"></div>
</div>

<select id="TariffList" style="display:none">
  <option value="Adult">Полный</option>
  <option value="Kid">Детский</option>
</select>
<script id="TmCtrlDroplist" type="text/html">
  <div>
    <span class="title">{{title}}</span>
    <select name="{{name}}"></select>
  </div>
</script>
<script id="TmCtrlString" type="text/html">
    <div>
      <span class="title">{{title}}</span>
      <input type="{{input_type}}" name="{{name}}"
        {{#maxlength}}maxlength="{{maxlength}}"{{/maxlength}}
        {{#placeholder}}placeholder="{{placeholder}}"{{/placeholder}} />
    </div>
</script>
<script id="TmCtrlDocNumber" type="text/html">
  <div>
    <span class="title">{{title}}</span>
    <div style="display:inline-block">
      <input type="{{input_type}}" name="{{name}}"
        {{#maxlength}}maxlength="{{maxlength}}"{{/maxlength}}
        {{#placeholder}}placeholder="{{placeholder}}"{{/placeholder}} />
      <div class="docnum-help">
        Формат номера: <span class="docnum-fmt"></span>
      </div>
    </div>
  </div>
</script>
  </xmp>
  
  <h5>CSS</h5>
  <pre class="css">
  form { display: inline-block; border: thin silver solid;}
  .rn-ctrl > div { padding: 0.5em 0.3em;}
  .title {display:inline-block; vertical-align:top; width:10em; text-align:right; padding-right:1em;}
  .rn-ctrl.invalid {background-color:#FEE;}
  .rn-ctrl.invalid .title {color:#C00;}
  .rn-required .title::after {content:"*"; color:#F00;} 
  .rn-ctrl input[type=text] { width:15em;}
  input[type=reset], input[type=submit] { margin-left:1em; padding:0.2em 1em;}
  .docnum-help { font-size:80%; color:#777; display:none;}
  .invalid .docnum-help {display:block;}
  .err-msg { display:none; border:thin solid #A00; border-radius: 0.5em;
       background-color: #FEE; color:#A00; cursor:pointer;
       padding:0.2em 1em 0.2em 2em; margin:0.4em 0.4em 0.4em 1em;}
  .err-msg:before { content: "!"; position: absolute; margin-left: -1.5em;
       border: thin solid #A00; border-radius: 0.5em; width: 1em; height: 1em;
       color: white; background-color: #C00; text-align: center; font-weight: bold; }</pre>
       
  <h5>JavaScript</h5>
  <pre class="jscript">
$(function(){
	Rn.init();
});
var g_DocTypes = {
	"1": { label:"Паспорт РФ", docRex:/^\d{10}$/, nameRex:/^[- А-ЯЁ]*$/i, fmt:'12 12 123456'},
	"2": { label:"Загранпаспорт", docRex:/^\d{9}$/, nameRex:/^[- A-Z]*$/i, fmt:'12 1234567'},
	"3": { label:"Свидетельство о рождении", docRex:/^[IVXL]+[А-ЯЁ]{2}\d{6}$/ ,
			nameRex:/^[- А-ЯЁ]*$/i, fmt:'VI БЯ 123456'},
	"4": { label:"Другой документ", docRex:/^.+$/, nameRex:/^[- A-ZА-ЯЁ]*$/i, fmt:'Любые символы'}
}, docRF=1, docInt=2, docBC=3; // Константы типов документов

// Требование № 4. Удаление разделительных символов
function filterDocNumber(docNumber) {
	return docNumber.replace(/[- №]/g, "");
}

// Класс формы ввода персональных данных
function FormPerson() {
	this.superClass = 'Base';
	this.onUpdate = function() {
		var docType = this.ctrls.docType.val();
		this.ctrls.midName.show(docType != docInt);
	}
	this.onReset = function() {
		$('#Result').empty();
	}
	this.onSubmit = function() {
		var data = this.save({}, true);
		$('#Result').text(JSON.stringify(data));
	}
	var $errMsg = null;
	this.check = function(errList) {
		$errMsg = $errMsg || $('.err-msg', this.$def);
		$errMsg.toggle(!!errList.length);
		if (errList.length) {
			var record = errList[0];
			$errMsg.html(record.msg);
			$errMsg.click(function(){
				if (record.ctrl)
					record.ctrl.focus();
				return false;
			});
		}
	}
}
// Контроллер типа документа
function CtrlDocList() {
	this.superClass = "Droplist";
	var lastTariff, lastDocType;
	this.onUpdate = function() {
		var tariff = this.owner.ctrls.tariff.val();
		var docType = this.value;
		// Требование № 6: Для детского тарифа убирать Паспорт РФ
		if (lastTariff != tariff) {
			lastTariff = tariff;
			if (lastTariff=='Kid' && docType==docRF)
				this.setValue(docBC);
			this.buildList();
		}
		if (docType != lastDocType) {
			lastDocType = docType;
			// Требование № 5: Вывод подсказки с форматом номера
			var helpText = g_DocTypes[docType].fmt;
			this.form.$def.find('.docnum-fmt').text(helpText);
		}
	}
	this.isValidOption = function(value, label) {
		return !(lastTariff=='Kid' && value==docRF);
	}
}
// Валидатор номера документа
function ValidatorDocNumber() {
	this.superClass = 'Regexp';
	// Использовать регулярное выражение для текущего типа документа
	this.getRegexp = function() {
		var docType = this.ctrl.owner.ctrls.docType.val();
		return g_DocTypes[docType].docRex;
	}
	// Требование № 4: удаление разделительных символов
	this.check = function(value) {
		return this.Regexp_check(filterDocNumber(value));
	}
}
// Требование № 4: удаление разделительных символов
function FilterDocNumber() {
	this.superClass = 'Base';
	this.filter = function(dstObj) {
		dstObj.docNumber = filterDocNumber(dstObj.docNumber);
	}
}
// Проверка значений ФИО, в зависимости от типа документа
function ValidatorPassName() {
	this.superClass = 'Base';
	this.check = function(value) {
		var docType = this.ctrl.owner.ctrls.docType.val();
		var regExp = g_DocTypes[docType].nameRex;
		return regExp.test(value) ? 0 : this.msg;
	}
}
// Требование к полю Отчество:
// обязательно для заполнения только для типов документа docRF и docBC.
function ValidatorNonEmptySometime() {
	this.superClass = 'Base';
	this.check = function(value) {
		if (value=='') {
			var docType = this.ctrl.owner.ctrls.docType.val();
			if (docType==docRF || docType==docBC)
				return this.msg;
		}
	}
}</pre>
  
  <h5>Диаграмма объектов</h5>
<svg id="Diag_FormPerson" width="48.5em" height="17.38em" viewBox="0 0 970 347.6">
  <rect class="class-box" x="353" y="6" width="184" height="22" rx="10" ry="10" />
  <text class="object-text" x="445" y="22">person: FormPerson</text>
  <rect class="class-box" x="105" y="70" width="160" height="22" rx="10" ry="10" />
  <text class="object-text" x="185" y="86">docType: CtrlDocList</text>
  <line class="line" x1="235" y1="70" x2="395" y2="28" />
  <rect class="class-box" x="625" y="70" width="160" height="22" rx="10" ry="10" />
  <text class="object-text" x="705" y="86">tariff: CtrlDroplist</text>
  <line class="line" x1="655" y1="70" x2="495" y2="28" />
  <rect class="class-box" x="149" y="121.2" width="192" height="21.9" rx="10" ry="10" />
  <text class="object-text" x="245" y="137.2">docNumber: CtrlString</text>
  <line class="line" x1="285" y1="121.2" x2="410" y2="28" />
  <rect class="class-box" x="5" y="166" width="160" height="22" rx="10" ry="10" />
  <text class="object-text" x="85" y="182">ValidatorNonEmpty</text>
  <line class="line" x1="145" y1="166" x2="185" y2="143.2" />
  <rect class="class-box" x="45" y="198" width="160" height="22" rx="10" ry="10" />
  <text class="object-text" x="125" y="214">ValidatorDocNumber</text>
  <line class="line" x1="175" y1="198" x2="205" y2="143.2" />
  <rect class="class-box" x="85" y="230" width="160" height="22" rx="10" ry="10" />
  <text class="object-text" x="165" y="246">FilterDocNumber</text>
  <line class="line" x1="215" y1="230" x2="235" y2="143.2" />
  <rect class="class-box" x="565" y="121.2" width="160" height="21.9" rx="10" ry="10" />
  <text class="object-text" x="645" y="137.2">midName: String</text>
  <line class="line" x1="605" y1="121.2" x2="480" y2="28" />
  <rect class="class-box" x="725" y="166" width="240" height="22" rx="10" ry="10" />
  <text class="object-text" x="845" y="182">ValidatorNonEmptySometime</text>
  <line class="line" x1="785" y1="166" x2="705" y2="143.2" />
  <rect class="class-box" x="685" y="198" width="160" height="22" rx="10" ry="10" />
  <text class="object-text" x="765" y="214">ValidatorPassName</text>
  <line class="line" x1="715" y1="198" x2="685" y2="143.2" />
  <rect class="class-box" x="645" y="230" width="160" height="22" rx="10" ry="10" />
  <text class="object-text" x="725" y="246">FilterNonEmpty</text>
  <line class="line" x1="675" y1="230" x2="655" y2="143.2" />
  <rect class="class-box" x="257" y="198" width="176" height="22" rx="10" ry="10" />
  <text class="object-text" x="345" y="214">lastName: CtrlString</text>
  <line class="line" x1="365" y1="198" x2="435" y2="28" />
  <rect class="class-box" x="457" y="198" width="176" height="22" rx="10" ry="10" />
  <text class="object-text" x="545" y="214">firstName: CtrlString</text>
  <line class="line" x1="525" y1="198" x2="455" y2="28" />
  <rect class="class-box" x="215" y="281.2" width="160" height="22" rx="10" ry="10" />
  <text class="object-text" x="295" y="297.2">ValidatorNonEmpty</text>
  <line class="line" x1="295" y1="281.2" x2="335" y2="220" />
  <rect class="class-box" x="281" y="319.6" width="168" height="22" rx="10" ry="10" />
  <text class="object-text" x="365" y="335.6">ValidatorPassName</text>
  <line class="line" x1="405" y1="319.6" x2="375" y2="220" />
  <rect class="class-box" x="425" y="281.2" width="160" height="22" rx="10" ry="10" />
  <text class="object-text" x="505" y="297.2">ValidatorNonEmpty</text>
  <line class="line" x1="485" y1="281.2" x2="505" y2="220" />
  <rect class="class-box" x="511" y="319.6" width="168" height="22" rx="10" ry="10" />
  <text class="object-text" x="595" y="335.6">ValidatorPassName</text>
  <line class="line" x1="635" y1="319.6" x2="555" y2="220" />
</svg>
  
  <h5>Пояснения</h5>
  Сначала рассмотрим основные требования, затем дополнительные.
  <ul>
  <li>
    Поле tariff реализовано в виде контроллера <a href="#Ref_CtrlDroplist">Droplist</a>.
    Список вариантов для него представлен элементом &lt;select id="TariffList" /&gt;
  </li>
  <li>
    Поле docType представлено контроллером DocList, который унаследован от <a href="#Ref_CtrlDroplist">Droplist</a>.
    В нём переопределяется функция <a href="#Ref_CtrlBase_onUpdate">onUpdate()</a>, чтобы выполнить требования 5 и 6.<br />
    Список вариантов формируется из переменной g_DocTypes. Значения вариантов представлены ключами объектов,
    поэтому <a href="#Ref_CtrlDroplist_option_value">data-option_value</a>="@".
    Кроме того, для каждого типа документа указано правило проверки номера документа (docRex), правило проверки ФИО (nameRex)
    и формат документа (fmt).<br />
    Чтобы по-умолчанию был выбран Паспорт РФ, используется атрибут <a href="#Ref_CtrlBase_value0">data-value0</a>="1".<br />
  </li>
  <li>
    Номер документа представлен контроллером <a href="#Ref_CtrlString">String</a>, однако к нему добавлены два
    <a href="#TxValidator">валидатора</a> и <a href="#TxFilters">фильтр</a>.<br />
    Валидатор <a href="#Ref_ValidatorNonEmpty">NonEmpty</a> делает поле обязательным для заполнения.<br />
    Валидатор <b>DocNumber</b> необходим для проверки формата вводимого номера документа, в зависимости от выбранного типа документа.
    Этот валидатор не является частью Radon и реализован в скриптовой части примера: function ValidatorDocNumber().
    Он является наследником <a href="#Ref_ValidatorRegexp">ValidatorRegexp</a>.
    В нём переопределяется метод <a href="#Ref_ValidatorRegexp_getRegexp">getRegexp()</a>, чтобы использовать регулярное выражение,
    которое описано в поле docRex структуры g_DocTypes.<br />
    Фильтр <b>FilterDocType</b> рассматривается в дополнительном требовании № 4.
  </li>
  <li>
    Фамилия вводится при помощи контроллера <a href="#Ref_CtrlString"></a>, снабженного двумя валидаторами:
    <ul>
    <li>стандартный <a href="#Ref_ValidatorNonEmpty">NonEmpty</a> применяется потому, что поле обязательно для заполнения;</li>
    <li>самописный <b>ValidatorPassName</b> служит для выполнения требования к ФИО, в зависимости от типа документа. </li>
    </ul>
  </li>
  <li>
    Имя вводится по тем же правилам, что и фамилия.
  </li>
  <li>
    Для контроллера <b>midName</b> используется самописный валидатор <b>ValidatorNonEmptySometime</b>,
    который делает поле обязательным для ввода только при выборе типа документа Паспорт РФ или Свидетельство о рождении.
  </li>
  </ul>
  <p>
    В данном примере сабмит формы выполнен в виде заглушки.
    Вместо AJAX-запроса в методе FormPerson.<a href="#Ref_FormBase_onSubmit">onSubmit()</a> происходит вывод полученной JSON-структуры в текстовом в виде
    в демонстрационный элемент <code>&lt;div id="Result"&gt;</code>.
    А переопределённый метод <a href="#Ref_RadonObject_onReset">onReset()</a> очищает этот элемент.
  </p>
  <h5>Теперь рассмотрим реализацию дополнительных требований</h5>
  <ol>
    <li>
      Система Radon практически никак не влияет на внешний вид разрабатываемой формы.
      Поэтому правильная вёрстка достигается путём использования CSS.<br />
      Вертикальное расположение полей достигается за счёт того, что теги &lt;div class="rn-ctrl" ...&gt; являются блочными элементами.<br />
      Свойство контроллера <a href="#Ref_CtrlBase_title">title</a> выводится внутри тега &lt;span class="title"&gt;.
      Так устроены все рекомендуемые шаблоны.
      Задав для класса .title свойство display:inline-block и фиксированную ширину, мы выполняем выравнивание всех названий полей.
    </li>
    <li>
      Красная звёздочка для обязательных полей выводятся при помощи CSS правила:
      <pre class="css">.rn-required .title::after {content:"*"; color:#F00;}</pre>
      Используется тот факт, что система Radon автоматически добавляет класс .rn-required к верхнему контейнеру контроллера
      (который обозначен классом rn-ctrl), при помощи вызова <a href="#Ref_CtrlBase_makeRequired">makeRequired()</a>.
    </li>
    <li>
      Отображение неправильно заполненных полей осуществляется такими CSS-правилами:
      <pre class="css">
  .rn-ctrl.invalid {background-color:#FEE;}
  .rn-ctrl.invalid .title {color:#C00;}</pre>
      Здесь используется тот факт, что стандартное поведение <a href="#Ref_CtrlBase_onError">CtrlBase.onError()</a>
      состоит в добавлении класса .invalid к элементу-описателю контроллера.<br />
      А для того чтобы ниже формы выводилось текстовое описание ошибки понадобилось следующее:
      <ul>
       <li><xmp><div class="err-msg"></div></xmp></li>
       <li>
         Переопределён метод check для класса <b>FormPerson</b>. В нём в случае ошибки делается видимым
         элемент .err-msg и в него выводится текст сообщения об ошибке.
         Кроме того, при клике на это сообщение фокус получит контроллер, сообщивший об ошибке.
       </li>
      </ul>
    </li>
    <li>
      Чтобы обеспечить возможность вводить номер документа в удобном для пользователя формате,
      потребовалось выполнить следующие действия:
      <ul>
      <li>Функция filterDocNumber удаляет из исходной строки пробелы, минусы и знак №.</li>
      <li>У валидатора ValidatorDocNumber переопределён метод check.</li>
      <li>Добавлен фильтр FilterDocNumber, чтобы в запрос номер отправлялся без лишних символов.</li>
      </ul>
    </li>
    <li>
      Для вывода подсказки о формате документа потребовалось использовать специальный шаблон контроллера
      TmCtrlDocNumber. Он скопирован с TmCtrlString, но в него добавлен фрагмент:
      <xmp>
    <div class="docnum-help">
        Формат номера: <span class="docnum-fmt"></span>
    </div></xmp>
      CSS правила:
      <pre class="css">
  .docnum-help { font-size:80%; color:#777; display:none;}
  .invalid .docnum-help {display:block;}</pre>
      Они обеспечивают невидимость подсказки, если ошибок нет. Но если появляется ошибка (класс invalid),
      то подсказка становится видимой.<br />
      А внутри CtrlDocList.onUpdate() есть код, который устанавливает текст подсказки в случае изменения типа документа:
      <pre class="jscript">
  var helpText = g_DocTypes[docType].fmt;
  this.form.$def.find('.docnum-fmt').text(helpText);</pre>
      Текст подсказки хранится в поле fmt для каждого типа документа в структуре g_DocTypes.
    </li>
    <li>
      Для модификации списка документов, в зависимости от тарифа, выполнены следующие действия:
      <ul>
        <li>
          В методе CtrlDocList.onUpdate() проверяется факт смены тарифа.
          Если выбран детский тариф и текущий тип документа - Паспорт РФ, то назначается текущий тип документа - Свидетельство о рождении.
          И перестраивается список вариантов вызовом <a href="#Ref_CtrlDroplist_buildList">buildList()</a>.
        </li>
        <li>
          Для класса CtrlDocList переопределён метод <a href="#Ref_CtrlDroplist_isValidOption">isValidOption()</a>.
          Он исключает из списка Паспорт РФ, если выбран детский тариф.
        </li>
      </ul>
    </li>
    <li>
      Чтобы скрывать поле Отчество в случае выбора типа документа Загранпаспорт, переопределён метод
      <a href="#Ref_RadonObject_onUpdate">onUpdate()</a> в классе FormPerson.
      Его реализация такова:
      <pre class="jscript">
	var docType = this.ctrls.docType.val();
	this.ctrls.midName.show(docType != docInt);
      </pre>
      Здесь запрашивается значение контроллера docType.
      А контроллер midName остаётся видимым только если тип документа не является загранпаспортом.
    </li>
    <li>
      Чтобы незаполненное поле Отчество не включалось в запрос, достаточно добавить к контроллеру midName
      фильтр <a href="#Ref_FilterNonEmpty">NonEmpty</a>.
    </li>
  </ol>
  <!-- end of FormPass example -->

  <!-- ****************** Array example ***************** -->
  <h3><a id="Ex_Array"></a>Использование контроллера Array</h3>
  <p>
    Контроллер <a href="#Ref_CtrlArray">Array</a> предназначен для ввода переменного числа элементов.
  </p>
  <p>
    Рассмотрим разработку формы, в которой вводится фамилия и несколько адресов.
    Каждый адрес состоит из полей: город, улица, дом. Один адрес необходим.
    Остальные добавляются по требованию пользователя, но не более трёх.
  </p>
  <p class="examples-ref">
    Действующая версия доступна в <a href="./rn-examples/Array.htm">Сборнике примеров</a>.
  </p>
  <h5>Описание формы</h5>
  <xmp>
    <form class="rn-form" name="info">
      <div class="rn-ctrl" data-name="name" data-type="String" data-title="Фамилия">
        <div class="rn-validator" data-type="NonEmpty"
             data-msg="Необходимо ввести фамилию"></div>
      </div>
      <div class="rn-ctrl" data-name="addr" data-type="Array" data-title="Адреса"
           data-item_tm="TmAddrItem" data-min="1" data-max="3"></div>
      <div class="buttons-box">
        <input class="rn-submit" type="submit" value="Готово" />
        <input class="rn-reset" type="reset" value="Сбросить" />
      </div>
    </form>
  </xmp>
  <p>
    Здесь описано всего два контроллера: name(<a href="#Ref_CtrlString">String</a>)
    и addr(<a href="#Ref_CtrlArray">Array</a>).
    Рассмотрим шаблон для контроллера массива:
  </p>
  <xmp>
    <script id="TmCtrlArray" type="text/html">
      <div>
        {{title}}:
        <div class="rn-array"></div>
        <button type="button" class="rn-add-item">Добавить адрес</button>
      </div>
    </script>
  </xmp>
  <p>
    Кнопка, помеченная классом <span class="css-class">rn-add-item</span>,
    служит для добавления адресов.
    Обратите внимание на атрибут <code>type="button"</code>.
    Он предотвращает сабмит формы, инициируемый кнопкой, при нажатии клавиши Enter.
  </p>
  <p>
    Здесь важный элемент помечен классом <span class="css-class">rn-array</span>.
    Именно в нём регистрируются элементы массива, генерируемые из шаблона TmAddrItem,
    указанного атрибутом <span class="hc-attr">data-item_tm</span>.
    Рассмотрим этот шаблон:
  </p>
  <xmp>
    <script id="TmAddrItem" type="text/html">
      <div class="address-frame">
        <a class="rn-del-item" title="Удалить" href="#del">×</a>
        <div class="rn-ctrl" data-name="city" data-type="String" data-title="Город">
          <div class="rn-validator" data-type="NonEmpty" data-msg="Нужно ввести город"></div>
        </div>
        <div class="rn-ctrl" data-name="street" data-type="String" data-title="Улица">
          <div class="rn-validator" data-type="NonEmpty" data-msg="Нужно ввести улицу"></div>
        </div>
        <div class="rn-ctrl" data-name="home" data-type="String" data-title="Дом"></div>
      </div>
    </script>
  </xmp>
  <p>
    Здесь можно видеть описание трёх контроллеров.
    Но ещё есть элемент с классом <span class="css-class">rn-del-item</span>.
    Он позволяет удалить элементы, если их количество больше одного.
  </p>
  <h5>Используемые CSS-стили</h5>
  <pre class="css">
    .address-frame {
      border: thin solid silver; margin:0.2em 0; padding: 0.2em 0.5em;
    }
    .address-frame .rn-del-item {
      position: absolute; display: inline-block; width: 1.5em; height: 1.5em;
      background: #999 linear-gradient(to bottom, #EEE, #888);
      border-radius: 100%; text-decoration: none;
      text-align: center; vertical-align: top; color: inherit;
    }
    .address-frame .rn-del-item.disabled {
      display: none;
    }
    div[data-name=home] input { width:3em; }
  </pre>
  <p>
    Здесь, в основном, отражены особенности вёрстки.
    А селектор <code>.address-frame .rn-del-item.disabled</code>
    позволяет скрыть кнопку удаления, если она запрещена.
  </p>
  <!-- end of Array example -->
  
  <!-- ****************** RatingBar ************************* -->
  
  <h3><a id="Ex_IntSlider"></a>Слайдер для ввода чисел</h3>
  <p>
    В этом примере мы рассмотрим разработку контроллера, который сочетает в себе различные способы ввода данных.
    Это контроллер для ввода целых чисел в заданном диапазоне. В нём присутствует строковый элемент и горизонтальный слайдер.
    Причём, изменения в одном элементе влияют на другой.
  </p>
  <style type="text/css">
  .slider {display:inline-block; position:relative; width:10em; height:1.2em;
    background-color:#EEE; vertical-align:top;  margin:0; padding:0; }
  .slider-shell {border:thin silver solid; margin:0; padding:0; display:inline-block;}
  .tracker {display:inline-block; width:0.75em; height:100%; position:absolute;
    margin :0; padding:0; box-sizing: border-box;
    border:2px outset #FFF; background-color:#CCC; cursor:pointer;
  }
  </style>
  Внешний вид его выглядит приблизительно так:
  <div class="space">
    <div class="slider-shell">
      <div class="slider"><div class="tracker" style="left:1em"></div></div>
    </div>
    <input type="text" value="10" size="2" />
  </div>
  <p class="examples-ref">
    Действующая версия доступна в <a href="./rn-examples/IntSlider.htm">Сборнике примеров</a>.
  </p>
  <p>
    Надо отметить, что ввод такого числа возможен и без разработки нового контроллера.
    Для этого можно воспользоваться базовой функциональностью системы Radon при помощи следующего описания:
  </p>
  <xmp>
  <div class="rn-ctrl" data-name="count" data-type="String" data-value0="1"
    data-title="Количество" >
    <div class="rn-validator" data-type="Integer" data-required="1"
      data-msg="Требуется целое число"></div>
    <div class="rn-validator"
      data-min="1" data-msg_min="Количество не должно быть меньше {{min}}"
      data-max="100" data-msg_max="Количество не должно быть больше {{max}}"></div>
  </div>
  </xmp>
  <p>
    Здесь используется контроллер <a href="#Ref_CtrlString">String</a> и два валидатора:
    <a href="#Ref_ValidatorInteger">Integer</a> и <a href="#Ref_ValidatorRange">Range</a>.
    Но, конечно же, наличие слайдера значительно повышает удобство ввода данных.
  </p>
  <p>
    Среди стандартных html-элементов слайдера нет. В некоторых браузерах есть вариант 
    &lt;input type="range" min="1" max="100" step="1" value="10" /&gt; :
    <input type="range" min="1" max="100" step="1" value="10" />.
    Но далеко не все браузеры его поддерживают. Да и те, что поддерживают, рисуют его по-разному.
    Поэтому для надёжности стоит воспользоваться готовыми решениями, например jQuery UI.
  </p>
  <p>
    Но здесь мы в демонстрационных целях разработаем слайдер "с нуля", используя только jQuery.<br />
    Класс контроллера будет назван <b>IntSlider</b>.
    В качестве родительского класса выберем <a href="#Ref_CtrlString">CtrlString</a>,
    так как в нём уже реализована работа со строкой ввода.
  </p>

  <p>
    Очевидно, что наличие слайдера предполагает чётко указанные границы значений: минимум и максимум.
    Поэтому они должны стать свойствами класса. 
    Контроль правильности значения тоже организуем внутри класса, а не в подключаемом валидаторе.
    Для этого будем переопределять функцию <a href="#Ref_CtrlBase_check">check()</a>.
    Кроме того, понадобятся сообщения об ошибках. Таких сообщений нужно три:
    если значение не является целым числом, если число меньше минимального и если больше максимального.
    Проще всего было бы определить их внутри описания класса примерно так:
  </p>
  <pre class="jscript"> this.msg = "Необходимо ввести целое число";</pre>
  <p>
    Но размещать текстовые сообщения внутри js-файлов крайне нежелательно,
    так как это приведёт к проблемам случае локализации системы (поддержки мультиязычности).
  </p>
  <p>
    Другой вариант - определять сообщения внутри описания контроллера.
    Но если форма будет включать несколько таких контроллеров, то понадобится указывать по три сообщения для каждого.
    Это приведёт к опасной избыточности.
  </p>
  <p>
    Поэтому принято решение вынести сообщения в глобальную структуру, называемую g_Lang.
    Её можно разместить в отдельном файле, что позволит применить какой-либо способ локализации.
  </p>
  Переходим непосредственно к реализации слайдера. Его конструкция состоит из трёх вложенных друг в друга элементов:
  <ul>
    <li>Ползунок (tracker) представляет элемент, который может горизонтально перемещаться.
      Он указывает значение контроллера относительно допустимого диапазона при помощи CSS-свойства <code class="css-prop">left</code>.
      Для него заведём CSS-правило: <code class="css-class">.tracker</code>.</li>
    <li>Рабочая область слайдера. Включает в себя ползунок. CSS-правило: <code class="css-class">.slider</code>.
      Для него важным условием является отсутствие отступов и рамок, чтобы точно вычислять положение ползунка.</li>
    <li>Элемент с CSS-классом <code class="css-class">.slider-shell</code> включает в себя рабочую область слайдера.
      Нужен для того, чтобы можно было нарисовать ограничивающую рамку.</li>
  </ul>
  Получаем следующую DOM-структуру:
  <xmp>
  <span class="slider-shell">
    <span class="slider">
      <span class="tracker"></span>
    </span>
  </span>
  </xmp>
 
  Для вычисления положения ползунка внутри слайдера воспользуемся пропорцией:
  <div align="center">
  <table class="proportion">
    <tr>
      <td><div>value - min</div><div class="divider">max - min</div></td>
      <td>=</td>
      <td><div>left</div><div class="divider">sliderWidth - trackerWidth</div></td>
    </tr>
  </table>
  </div>
  <p>
    Функция world2screen в коде примера служит для вычисления left из value,
    а функция screen2world вычисляет value из положения ползунка.
    Здесь используется терминология из машинной графики.
    Экранными координатами являются left, sliderWidth и trackerWidth.
    А в мировых координатах находятся min, max и value.
  </p>
  <p>
    В нашем примере слайдер имеет фиксированный размер, поэтому его ширина вычисляется один раз.
    Иначе нужно было бы отслеживать событие onresize.
    А пересчитывание размеров при каждом вычислении может снизить эффективность выполнения кода,
    т.к. обращение к свойствам DOM-элементов выполняется довольно медленно.
  </p>
  <p>Теперь необходимо решить вопросы синхронизации.
    У нас есть три объекта: значение <a href="#Ref_CtrlValue_value">this.value</a>, элемент &lt;input&gt; и ползунок.
    При изменении любого из них остальные тоже должны принимать соответствующее значение.<br />
    Как это должно происходить:
  </p>
  <ul>
    <li>Для изменения значения контроллера из скрипта используется <a href="#Ref_CtrlValue_setValue">setValue()</a>.
      Из неё уже вызывается метод <a href="#Ref_CtrlValue_val2dom">val2dom()</a>, который мы переопределяем.
      Вызов String_val2dom() синхронизирует строковый элемент, а world2screen позиционирует ползунок.
    </li>
    <li>Если пользователь что-то вводит с через элемент input, то вызывается <a href="#Ref_CtrlValue_fromDOM">fromDOM()</a>,
      а из него вызывается <a href="#Ref_CtrlValue_dom2val">dom2val()</a>, который мы тоже переопределяем.
      В нём после вызова String_dom2val() заполняется value, а ползунок позиционируется через world2screen.
    </li>
    <li>
      Если пользователь кликает на рабочую область слайдера, то вычисляется экранная координата x 
      при помощи функции calcScreenPos. А затем вызовом screen2world заполняются value и строка ввода.
      Затем срабатывает <a href="#Ref_Rn_update">update</a> системы.
    </li>
    <li>
      Самый сложный случай - перетаскивание ползунка. Сначала фиксируется событие mousedown на ползунке.
      При этом устанавливается state=1, что означает захват мышки нашим контроллером.
      В случае события mouseup мы сбрасываем обратно state=0. То есть, отпускаем мышку.
      А события mousemove в случае state=1 приводят к вызову calcScreenPos, screen2world и
      <a href="#Ref_Rn_update">update</a>.
    </li>
  </ul>
  <p>
    Ну и наконец, смотрим код примера:
  </p>
  <h5>CSS</h5>
  <pre class="css">
.tracker {display:inline-block; width:0.75em; height:100%; position:absolute;
  margin:0; padding:0;
  border:2px outset #FFF; background-color:#CCC; cursor:pointer;
  box-sizing: border-box;
}
.slider {display:inline-block; position:relative; width:10em; height:1.2em;
    background-color:#EEE; vertical-align:top;  margin:0; padding:0;
}
.slider-shell {border:thin silver solid; margin:0; padding:0; display:inline-block;}</pre>

  <h5>JavaScript</h5>
  <pre class="jscript">
 function CtrlIntSlider() {
	this.superClass = "String";
	var $slider, sliderWidth,
		$tracker, trackerWidth,
		screenWidth = 0;
	this.$slider = 0;
	this.msg = g_Lang.sliderMsg;
	this.msg_min = g_Lang.sliderMin;
	this.msg_max = g_Lang.sliderMax;
	this.min = this.value0 = 0;
	this.max = 100;
	function getRange(ctrl) {
		var range = {a:+ctrl.min, b:+ctrl.max};
		range.w = range.b - range.a;
		return range;
	}
	function bound(range, value) {
		return Math.max(Math.min(value, range.b), range.a);
	}
	function world2screen(ctrl, value) {
		var range = getRange(ctrl);
		if (range.w && $tracker) {
			var dx = (bound(range, value)-range.a) * screenWidth / range.w;
			$tracker.css('left', dx);
		}
	}
	function screen2world(ctrl, pos) {
		var range = getRange(ctrl);
		if (screenWidth && $tracker) {
			var worldValue = bound(range, Math.round(pos * range.w / screenWidth + range.a));
			ctrl.$edit.val(worldValue);
			ctrl.fromDOM();
			$tracker.css('left', bound({a:0, b:screenWidth}, pos));
		}
	}
	this.render = function() {
		var ctrl = this;
		ctrl.String_render();
		ctrl.$slider = $slider = $('.slider', ctrl.$def);
		$tracker = $('&lt;div&gt;').addClass('tracker').prependTo($slider);
		// Размеры в пикселях
		trackerWidth = $tracker.outerWidth();
		sliderWidth = $slider.innerWidth();
		screenWidth = sliderWidth - trackerWidth;
		var state=0, trackX;
		function calcScreenPos(ev) {
			return ev.pageX - trackX - $slider.offset().left;
		}
		$tracker.mousedown(function(ev){
			state=1;
			trackX = ev.pageX - $tracker.offset().left;
		});
		$(window).mouseup(function(ev) {
			state=0;
			world2screen(ctrl, ctrl.value);
		}).mousemove(function(ev){
			if (!state) return;
			screen2world(ctrl, calcScreenPos(ev));
			ev.preventDefault();
		});
		$slider.click(function(ev){
			trackX = trackerWidth/2;
			screen2world(ctrl, calcScreenPos(ev));
			return false;
		});
		world2screen(this, this.value);
	}
	this.check = function(errList) {
		var val = this.value;
		if (!/^-?\d+$/.test(val))
			return this.msg;
		if (val &lt; this.min)
			return Rn.templText(this.msg_min, this);
		if (val &gt; this.max)
			return Rn.templText(this.msg_max, this);
		return this.String_check(errList);
	}
	this.isRequired = function() {
		return !!this.required;
	}
	this.val2dom = function() {
		this.String_val2dom();
		world2screen(this, this.value);
	}
	this.dom2val = function() {
		this.String_dom2val();
		world2screen(this, this.value);
	}
	this.validValue = function() {
		return Math.max( Math.min(this.value || 0, +this.max), +this.min);
	}
 }

// Сообщения об ошибках
var g_Lang = {
	sliderMsg: "Необходимо ввести целое число",
	sliderMin: "Значение не должно быть меньше {{min}}",
	sliderMax: "Значение не должно быть больше {{max}}"
};
  </pre>

<p>
  Кода получилось довольно много. Но нужно понимать, что здесь реализация скрыта за интерфейсом.
  То есть, большинство компонентов системы общаются друг с другом по определённым правилам
  и сложность реализации каждого не особо влияет на общую сложность системы.
  В объектно-ориентированном программировании это называется <em>Инкапсуляция</em>.
</p>
<p>
  В результате мы получили новый класс контроллера, пригодный к многократному использованию.
  Он используется в <a href="Ex_ColorPicker">следующем примере</a>.<br />
  А сейчас краткая документация для удобства дальнейшего пользования.
</p>
  <h5><a id="Ref_CtrlIntSlider"></a>Диаграмма классов</h5>
<svg id="Diag_CtrlIntSlider" width="28.9em" height="1.7em" viewBox="0 0 578 34">
  <rect class="class-box" x="5" y="6" width="104" height="22" />
  <text class="class-text selected" x="57" y="22">IntSlider</text>
  <rect class="class-box" x="167" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlString">
    <text class="class-text" x="207" y="22">String</text>
  </a>
  <path class="line" d="M109 17 L156 17 L156 11.5 L167 17 L156 22.5 L156 17" />
  <rect class="class-box" x="317" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlValue">
    <text class="class-text" x="357" y="22">Value</text>
  </a>
  <path class="line" d="M247 17 L306 17 L306 11.5 L317 17 L306 22.5 L306 17" />
  <rect class="class-box" x="460.9" y="6" width="112" height="22" />
  <a xlink:href="#Ref_RadonObject">
    <text class="class-text" x="517" y="22">RadonObject</text>
  </a>
  <path class="line" d="M397 17 L404.5 17 M412.1 17 L419.7 17 M427.2 17 L434.8 17 M442.4 17 L449.9 17 L449.9 11.5 L460.9 17 L449.9 22.5 L449.9 17" />
</svg>
  <h5>Пример описания</h5>
  <xmp>
  <div class="rn-ctrl" data-name="R" data-type="IntSlider"
      data-min="10" data-max="100" data-value0="50" data-title="Радиус"></div>
  </xmp>
  <h5>Рекомендуемый шаблон</h5>
  <xmp>
<script id="TmCtrlIntSlider" type="text/html">
  <div>
    <span class="title">{{title}}</span>
    <span class="slider-shell"><span class="slider"></span></span>
    <input type="text" name="{{name}}" size="2" />
  </div>
</script>
  </xmp>
  <table class="ref-tbl">
  <tr>
    <td>validValue()</td>
    <td>
      <pre class="signature">int validValue() const</pre>
      Возвращает корректное числовое значение контроллера. Даже если он в состоянии ошибки ввода.<br />
      Полезен для использования в скрипте, т.к. <a href="#Ref_CtrlValue_value">value</a> может содержать ошибочно заполненное значение.
    </td>
  </tr>
  </table>
  
  <!-- end of IntSlider example -->

  <!-- ****************** ColorPicker ************************* -->
  
  <h3><a id="Ex_ColorPicker"></a>Форма для выбора цвета</h3>
  <p>
    Этот пример посвящён довольно сложной теме: разработке формы, в которой разные контроллеры взаимно влияют друг на друга.<br />
    Изготовим форму для выбора цвета.
    Так чтобы с помощью слайдеров можно было выбирать уровни цветовых компонент для RGB и HSL моделей.
    А ещё можно редактировать цвет в виде HTML-описания, представляющего собой шеснадцатеричное число с 6 знаками.
    Например, FF0000 - красный.<br />
    Подобные формы есть практически в любом графическом редакторе и других дизайнерских инструментах.
  </p>
  <h5>Эскиз формы</h5>
  <form class="rn-form color-picker">
    <div class="rn-ctrl">
      <span class="title">Красный</span>
      <span class="slider-shell"><span class="slider" style="background:linear-gradient(to right, #000, #F00)"
        ><span class="tracker" style="left:9.3em"></span></span></span>
      <input type="text" value="255" size="2" />
    </div>
    <div class="rn-ctrl">
      <span class="title">Зелёный</span>
      <span class="slider-shell"><span class="slider" style="background:linear-gradient(to right, #F00, #FF0)"
        ><span class="tracker"></span></span></span>
      <input type="text" value="0" size="2" />
    </div>
    <div class="rn-ctrl">
      <span class="title">Синий</span>
      <span class="slider-shell"><span class="slider" style="background:linear-gradient(to right, #F00, #F0F)"
        ><span class="tracker"></span></span></span>
      <input type="text" value="0" size="2" />
    </div>
    <div class="rn-ctrl">
      <span class="title">Тон</span>
      <span class="slider-shell"><span class="slider" style="background:linear-gradient(to right, #F00,#FF0,#0F0,#0FF,#00F,#F0F,#F00)"
        ><span class="tracker"></span></span></span>
      <input type="text" value="0" size="2" />
    </div>
    <div class="rn-ctrl">
      <span class="title">Насыщенность</span>
      <span class="slider-shell"><span class="slider" style="background:linear-gradient(to right, #7F7F7F, #F00)"
        ><span class="tracker" style="left:9.3em"></span></span></span>
      <input type="text" value="100" size="2" />
    </div>
    <div class="rn-ctrl">
      <span class="title">Яркость</span>
      <span class="slider-shell"><span class="slider" style="background:linear-gradient(to right, #000, #FFF)"
        ><span class="tracker" style="left:4.6em"></span></span></span>
      <input type="text" value="50" size="2" />
    </div>
    <div class="rn-ctrl">
      <span class="title">HTML-разметка</span>
      <input type="text" value="FF0000" />
    </div>
    <div class="rn-ctrl">
      <span class="title">Цвет</span>
      <span class="color-demo"></span>
    </div>
  </form>
  
  <div class="examples-ref">
    Действующая форма в <a href="./rn-examples/ColorPicker.htm">Сборнике примеров</a>.
  </div>
  <p>
    Здесь используется контроллер IntSlider, который был разработан в
    <a href="#Ex_IntSlider">предыдущем примере</a>.
    А фон слайдеров изображен градиентом, демонстрирующим, как будет меняться цвет, в зависимости от положения ползунка.
  </p>
  <p>
    Назовём контроллеры в соответствии с названиями каналов: R, G, B, H, S, L.
    Значения R, G и B меняются в диапазоне [0;255]. Значение H меняется в диапазоне [0;360].
    Значения S и L меняются от 0 до 100.<br />
    А контроллер "HTML-разметка" получает имя html.
  </p>
  <p>
    Чтобы пересчитывать RGB в HSL и обратно, в коде примера присутствуют функции cvtRGBtoHSL и cvtHSLtoRGB,
    которые занимают почти половину кода. Они оперируют значениями в диапазоне от 0 до 1.
    А внутри класса формы есть методы rgb2hsl и hsl2rgb,
    которые читают данные из одних контроллеров и устанавливают другие.
  </p>
  <p>
    А теперь рассмотрим основную проблему, которую предстоит решить.
    Что должно произойти, если мы начнём двигать ползунок, допусим, контроллера яркости (L) ?
    Должны начать меняться значения контроллеров R, G и B.<br />
    Стандартный способ отслеживать изменения в системе Radon - переопределение функции
    <a href="#Ref_RadonObject_onUpdate">onUpdate</a>.
    Допустим мы переопределили onUpdate для контроллера L. Там фиксируем изменение значения и
    вычисляем значения для R, G и B... 
    Но как только для контроллеров будут вызваны методы <a href="#Ref_CtrlValue_setValue">setValue</a>,
    случится очередной <a href="#Ref_Rn_update">update</a>, который вызовет onUpdate у контроллеров.
    Они зафиксируют изменения и сами попытаются пересчитать RGB в HSL.
    То есть, происходит какая-то цепная реакция. А нам этого не нужно.<br />
    Причём, такая проблема случается не из-за каких-то недостатков системы Radon. 
    При наличии контроллеров, влияющих друг на друга, эту задачу необходимо решать в любой системе.
  </p>
  <p>
    Предлагается следующий вариант решения: контроллер фиксирует изменения, которые совершил пользователь,
    и сообщает об этом своей форме. А форма устанавливает значения только для нужных контроллеров.
  </p>
  <p>
    Концепция контроллеров-наследников <a href="#Ref_CtrlValue">CtrlValue</a> предписывает в случае изменения
    пользователем DOM-элемента ввода вызывать метод <a href="#Ref_CtrlValue_fromDOM">fromDOM</a>.
    И контроллер <a href="#Ref_CtrlString">CtrlString</a> делает это.
    Но мы пользуемся классом <a href="#Ref_CtrlIntSlider">CtrlIntSlider</a>. Кроме элемента ввода там есть слайдер,
    при изменении которого срабатывает внутренняя функция screen2world, внутри которой тоже вызывается fromDOM().<br />
    Поэтому создадим класс-наследник CtrlIntSlider и переопределим в нём метод fromDOM.
    Назовём этот класс <b>CtrlColorComponent</b>.<br />
    Так же потребуется наследник CtrlString для контроллера HTML-разметки.
    Его назовём <b>CtrlHTMLColor</b>.
  </p>
  Реализация метода fromDOM для классов CtrlColorComponent и CtrlHTMLColor работает одинаково. Сначала выполняется
  <pre class="jscript">
	this.form.changedChannel = this.name;
  </pre>
  <p>
    Таким образом форма получает имя контроллера, в котором произошло изменение. А затем вызывается метод fromDOM родительского класса,
    который вызовет <a href="#Ref_Rn_update">update</a>.
  </p>
  <p>
    Класс формы называется <b>FormColorPicker</b>. Его метод <a href="#Ref_FormBase_onUpdate">onUpdate</a> состоит из двух частей.<br />
    В первой части происходит анализ ситуации, когда один из контроллеров установил свойство changedChannel.<br />
    Во второй части в случае изменения цвета устанавливается <code class="css-prop">background-color</code> элемента
    <code class="css-class">.color-demo</code>, чтобы пользователь видел полученный цвет.
    А так же устанавливается значение контроллера html, за исключением той ситуации, когда новый цвет получен редактированием этого контроллера.
  </p>
  <p>
    Осталось рассмотреть формирование градиентов для слайдеров.<br />
    Тон и Яркость выведены статическим градиентом. Это сделано очень просто.
  </p>
  <xmp>
    <div class="rn-ctrl hue" data-name="H" ...></div>
    <div class="rn-ctrl lightness" data-name="L" ...></div>
  </xmp>
  <pre class="css">
  .hue .slider {background:linear-gradient(to right,#F00,#FF0,#0F0,#0FF,#00F,#F0F,#F00);}
  .lightness .slider {background:linear-gradient(to right, #000,#FFF);}</pre>

  <p>
    Остальные градиенты формируются динамически. Для этого необходимо сделать класс-наследник от IntSlider и переопределить
    для него <a href="#Ref_CtrlBase_onUpdate">onUpdate()</a>. Для Насыщенности создаём класс <b>CtrlSaturation</b>.
    А для трёх цветовых каналов - класс <b>CtrlRGBChannel</b>.
  </p>

  <h5>Диаграмма классов контроллеров, используемых в форме выбора цвета</h5>
<svg id="Diag_ColorPickerClasses" width="28.4em" height="8.1em" viewBox="0 0 568 162">
  <rect class="class-box" x="71" y="6" width="104" height="22" />
  <a xlink:href="#Ref_CtrlIntSlider">
    <text class="class-text" x="123" y="22">IntSlider</text>
  </a>
  <rect class="class-box" x="243" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlString">
    <text class="class-text" x="283" y="22">String</text>
  </a>
  <path class="line" d="M175 17 L232 17 L232 11.5 L243 17 L232 22.5 L232 17" />
  <rect class="class-box" x="59" y="70" width="128" height="22" />
  <text class="class-text" x="123" y="86">ColorComponent</text>
  <path class="line" d="M123 70 L123 39 L117.5 39 L123 28 L128.5 39 L123 39" />
  <rect class="class-box" x="5" y="134" width="96" height="22" />
  <text class="class-text" x="53" y="150">RGBChannel</text>
  <path class="line" d="M73 134 L88.2 101.9 L83.3 99.5 L93 92 L93.2 104.2 L88.2 101.9" />
  <rect class="class-box" x="145" y="134" width="96" height="22" />
  <text class="class-text" x="193" y="150">Saturation</text>
  <path class="line" d="M173 134 L157.7 101.9 L152.7 104.2 L153 92 L162.6 99.5 L157.7 101.9" />
  <rect class="class-box" x="231" y="70" width="104" height="22" />
  <text class="class-text" x="283" y="86">HTMLColor</text>
  <path class="line" d="M283 70 L283 39 L277.5 39 L283 28 L288.5 39 L283 39" />
  <rect class="class-box" x="363" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlValue">
    <text class="class-text" x="403" y="22">Value</text>
  </a>
  <path class="line" d="M323 17 L352 17 L352 11.5 L363 17 L352 22.5 L352 17" />
  <rect class="class-box" x="483" y="6" width="80" height="22" />
  <a xlink:href="#Ref_CtrlBase">
    <text class="class-text" x="523" y="22">Base</text>
  </a>
  <path class="line" d="M443 17 L472 17 L472 11.5 L483 17 L472 22.5 L472 17" />
</svg>

  <p>Ну и наконец, код примера:</p>
  
  <h5>HTML код формы</h5>
  <xmp>
  <form class="rn-form" name="color" data-type="ColorPicker">
    <div class="rn-ctrl" data-name="R" data-type="RGBChannel" data-title="Красный"></div>
    <div class="rn-ctrl" data-name="G" data-type="RGBChannel" data-title="Зелёный"></div>
    <div class="rn-ctrl" data-name="B" data-type="RGBChannel" data-title="Синий"></div>
    <div class="rn-ctrl hue" data-name="H" data-type="ColorComponent"
        data-max="360" data-title="Тон"></div>
    <div class="rn-ctrl" data-name="S" data-type="Saturation" data-title="Насыщенность"></div>
    <div class="rn-ctrl lightness" data-name="L" data-type="ColorComponent" data-title="Яркость"></div>
    <div class="rn-ctrl" data-name="html" data-type="HTMLColor"
        data-title="HTML-разметка" data-msg="Ошибка в описании цвета"></div>
    <div>
      <span class="title">Цвет</span>
      <div class="color-demo"></div>
    </div>
    <div class="buttons-box>
      <input type="submit" value="Ready" />
    </div>
  </form>
  </xmp>
  
  <h5>Шаблоны</h5>
  <xmp>
  <script id="Script1" type="text/html">
    <div>
      <span class="title">{{title}}</span>
      <span class="slider-shell"><span class="slider"></span></span>
      <input type="text" name="{{name}}" size="2" />
    </div>
  </script>
  <script id="TmCtrlHTMLColor" type="text/html">
    <div>
      <span class="title">{{title}}</span>
      <input type="text" name="{{name}}" size="6" />
    </div>
  </script>
  <script type="text/jscript">
	var g_Lang = {
		sliderMsg: "Необходимо ввести целое число",
		sliderMin: "Значение не должно быть меньше {{min}}",
		sliderMax: "Значение не должно быть больше {{max}}"
	};
  </script>
  </xmp>
  <h5>CSS</h5>
  <pre class="css">
.color-demo { display: inline-block; vertical-align:top; height:2em; width:8em; border:thin black solid;}
.hue .slider {background:linear-gradient(to right,#F00,#FF0,#0F0,#0FF,#00F,#F0F,#F00);}
.lightness .slider {background:linear-gradient(to right, #000,#FFF);}</pre>

  <h5>JavaScript</h5>
  <pre class="jscript">
 // Формирование html-описания цвета из массива значений [0;255]
 function makeRGB(a) {
	return 'rgb('+a[0]+','+a[1]+','+a[2]+')';
 }
 // Формирование html-описания цвета из массива значений [0;1]
 function makeRGB1(a) {
	var i, b=[];
	for (i=0; i&lt;3; i++)
		b[i] = Math.floor(a[i]*255);
	return makeRGB(b);
 }

 // Входные и выходные значения в диапазоне от 0 до 1
 function cvtRGBtoHSL(r, g, b) {
	var H, S, L,
		cmin = Math.min(r, g, b),
		cmax = Math.max(r, g, b);
	if (cmin==cmax) {
		H = S = 0;
		L = cmin;
	} else {
		L = (cmin+cmax)/2;
		S = 0.5*(cmax-cmin)/(L &gt; 0.5 ? 1-L : L);
		var val, part;
		if (cmax==r) {	// red maximum
			if (cmin==b) {
				part = 0;	val = g;
			} else {
				part = 5;	val = 1-b;
			}
		} else if (cmax==g) {	// green maximum
			if (cmin==r) {
				part = 2;	val = b;	// blue up
			} else {
				part = 1;	val = 1-r;	// red down
			}
		} else {	// blue maximum
			if (cmin==g) {
				part = 4;	val = r;	// red up
			} else {
				part = 3;	val = 1-g;	// green down
			}
		}
		H = (part+val)/6;
	}
	return [H, S, L];
 } // cvtRGBtoHSL

 // Входные и выходные значения в диапазоне от 0 до 1
 function cvtHSLtoRGB(H, S, L) {
	var	Nr=0, Ng=1, Nb=2,	// номера RGB-компонент
		rgb=[0, 0, 0];
	function initH(hi, lo, med, v) {
		rgb[hi] = 1;
		rgb[lo] = 0;
		rgb[med] = v;
	}
	H *= 6;	// hue
	if (H&gt;=6) H=0;
	var n = Math.floor(H);
	switch (n) {
	case 1:
		initH(Ng, Nb, Nr, 2-H); break;
	case 2:
		initH(Ng, Nr, Nb, H-2);	break;
	case 3:
		initH(Nb, Nr, Ng, 4-H);	break;
	case 4:
		initH(Nb, Ng, Nr, H-4);	break;
	case 5:
		initH(Nr, Ng, Nb, 6-H);	break;
	default:
		initH(Nr, Nb, Ng, H);	break;
	}
	// saturation
	var j, sn = 1-S, Cs;
	for (j=0; j&lt;3; j++) {
		Cs = rgb[j];
		rgb[j] = Cs + sn*(0.5-Cs);
	}
	// lightness
	var l2 = 2 * L;
	if (l2 &gt; 1.0) {
		l2 -= 1;
		for (j=0; j&lt;3; j++) {
			Cs=rgb[j];
			rgb[j] = Cs + (1-Cs)*l2;
		}
	} else {
		for (j=0; j<3; j++) {
			rgb[j] *= l2;
		}
	}
	return rgb;
 } // cvtHSLtoRGB

 // Контроллер для выбора цветового компонента
 function CtrlColorComponent() {
	this.superClass = 'IntSlider';
	this.min = 0;
	this.fromDOM = function() {
		this.form.changedChannel = this.name;
		this.IntSlider_fromDOM();
	}
	// Установить фоновый градиент
	// colors - массив цветов, например ['#000','#FFF']
	this.setGradient = function(colors) {
		this.$slider.css('background', 'linear-gradient(to right,'+colors.join(',')+')');
	}
 }

 // Контроллер для выбора одного из цветовых каналов R,G,B
 function CtrlRGBChannel() {
	this.superClass = 'ColorComponent';
	this.max = 255;
	
	var prevKey;
	this.onUpdate = function() {
		var color1=this.form.getRGB(),
			color2=[], i;
		for (i=0; i!=3; i++) {
			if ("RGB"[i]==this.name) {
				color1[i] = 0;
				color2[i] = 255;
			} else {
				color2[i] = color1[i];
			}
		}
		var c1 = makeRGB(color1), c2 = makeRGB(color2),
			key = c1+c2;
		if (key!==prevKey) {
			prevKey = key;
			this.setGradient([c1, c2]);
		}
	}
 }
 // Контроллер для выбора Насыщенности
 function CtrlSaturation() {
	this.superClass = 'ColorComponent';
	var prevKey;
	this.onUpdate = function() {
		var ctrls = this.form.ctrls,
			H = ctrls.H.validValue()/360,
			L = ctrls.L.validValue()/100,
			low = makeRGB1(cvtHSLtoRGB(H, 0, L)),
			med = makeRGB1(cvtHSLtoRGB(H, 0.5, L)),
			hi = makeRGB1(cvtHSLtoRGB(H, 1, L)),
			key = low+med+hi;
		if (key !== prevKey) {
			prevKey = key;
			this.setGradient([low, med, hi]);
		}
	}
 }
 // Контроллер для ввода HTML-цвета
 function CtrlHTMLColor() {
	this.superClass = 'String';
	this.fromDOM = function() {
		this.form.changedChannel = this.name;
		this.String_fromDOM();
	}
	this.getRGB = function() {
		var i, rgb=[0,0,0], srcValue = this.value;
		if (!/^[\dA-F]+$/i.test(srcValue))
			return 0;
		if (srcValue.length==6) {
			for (i=0; i&lt;3; i++)
				rgb[i] = parseInt(srcValue.slice(i*2, i*2+2), 16);
		} else if (srcValue.length==3) {
			for (i=0; i&lt;3; i++) {
				var v = parseInt(srcValue[i], 16);
				rgb[i] = v + (v << 4);
			}
		} else return 0;
		return rgb;
	}
	this.check = function() {
		if (!this.getRGB())
			return this.msg;
	}
 }

 // Форма для выбора цвета
 function FormColorPicker() {
	this.superClass = 'Base';
	this.changedChannel = 0;
	this.getRGB = function() {
		var ctrls = this.ctrls;
		return [ctrls.R.validValue(),
			ctrls.G.validValue(), ctrls.B.validValue()];
	}
	var Hex = '0123456789ABCDEF';
	function hexStr(v) {
		return Hex[v >> 4] + Hex[v & 0xF];
	}
	this.htmlColor = function() {
		var rgb = this.getRGB();
		return hexStr(rgb[0]) + hexStr(rgb[1]) + hexStr(rgb[2]);
	}
	var prevColor, $colorDemo, lastChannel;
	this.onUpdate = function() {
		var c = this.changedChannel;
		if (c) {
			lastChannel = c;
			this.changedChannel = 0;
			if ("RGB".indexOf(c)&gt;=0) {
				this.rgb2hsl();
			} else if ("HSL".indexOf(c)&gt;=0) {
				this.hsl2rgb();
			} else if (c=='html') {
				var i, ctrls = this.ctrls,
					rgb = ctrls.html.getRGB();
				if (rgb) for (i=0; i&lt;3; i++)
					ctrls["RGB"[i]].setValue(rgb[i]);
				this.rgb2hsl();
			}
		}
		var color = this.htmlColor();
		if (prevColor !== color) {
			prevColor = color;
			$colorDemo = $colorDemo || $('.color-demo', this.$def);
			$colorDemo.css('background-color', '#'+color);
			if (lastChannel!='html') {
				this.ctrls.html.setValue(color);
			} else lastChannel = 0;
		}
	}
	this.rgb2hsl = function() {
		prevLocker = this.changeCounter;
		var ctrls=this.ctrls,
			b = ctrls.B.validValue()/255,
			g = ctrls.G.validValue()/255,
			r = ctrls.R.validValue()/255,
			hsl = cvtRGBtoHSL(r,g,b);
		
		ctrls.H.setValue(Math.floor(hsl[0]*360));
		ctrls.S.setValue(Math.floor(hsl[1]*100));
		ctrls.L.setValue(Math.floor(hsl[2]*100));
	}	// rgb3hsl
	
	this.hsl2rgb = function() {
		var i, ctrls = this.ctrls,
			H = ctrls.H.validValue()/360,
			S = ctrls.S.validValue()/100,
			L = ctrls.L.validValue()/100,
			rgb = cvtHSLtoRGB(H,S,L);
		for (i=0; i!=3; i++)
			ctrls["RGB"[i]].setValue(Math.floor(255*rgb[i]));
	}	// hsl2rgb
 } // form
  </pre>

  <!-- end of ColorPicker example -->
  
</div><!-- id="all-text" -->
</body>
</html>
